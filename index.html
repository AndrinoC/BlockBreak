<!DOCTYPE html>
<html lang="pt-br">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>BlockBreaker</title>
    <style>
      body {
        background-color: #121212;
        color: #ffffff;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        height: 100vh;
        margin: 0;
        font-family: "Consolas", "Courier New", monospace;
        overflow: hidden;
      }

      canvas {
        background-color: #282828;
        border-radius: 8px;
        box-shadow: 0 0 20px rgba(255, 255, 255, 0.1);
        max-width: 100%;
        max-height: 100%;
      }
    </style>
  </head>

  <body>
    <canvas id="gameCanvas"></canvas>
    <script>
      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");
      const aspectRatio = 9 / 16;
      let canvasHeight, canvasWidth;
      let UI_AREA_HEIGHT = 0;

      let startTime = 0;
      let totalPausedTime = 0;
      let pauseStartTime = 0;

      let gameUiButtons = [];
      let powerUps = [];
      let nextLaunchPositionX = 0;
      let firstBallReturnedThisRound = false;
      let waveCountSinceLastPowerUp = 0;
      let ballIdCounter = 0;
      let powerUpIdCounter = 0;
      let recallButton = {};

      const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

      const BRICK_COLUMNS = 8;
      const SPEED_UP_MULTIPLIER = 2;
      const LAUNCH_INTERVAL_MS = 150;
      const NORMAL_BALL_TRAIL_LENGTH = 10;
      const BALL_DAMAGE = 1;

      let ballRadius = 8;
      let brickSize = canvas.width / BRICK_COLUMNS;
      let balls = [];
      let bricks = [];
      let particles = [];
      let floatingTexts = [];
      let visualEffects = [];

      let gameState = "aiming";
      let ballsToLaunch = 1;
      let ballsReturned = 0;
      let wave = 0;
      let score = 0;
      let totalBallsLaunchedThisRound = 0;
      let aimAngle = -Math.PI / 2;
      let isAiming = false;
      let isSpeedingUp = false;
      let mouse = { x: 0, y: 0 };
      let previousGameState = "";
      let uiButtons = [];
      let launchIndex = 0;
      let launchTimer = 0;
      let currentLaunchQueue = [];

      const launchPosition = {
        x: canvas.width / 2,
        y: canvas.height - 30,
      };

      let screenShake = {
        intensity: 0,
        duration: 0,
      };

      function resizeGame() {
        const windowHeight = window.innerHeight;
        const windowWidth = window.innerWidth;
        let newCanvasHeight = windowHeight * 0.9;
        let newCanvasWidth = newCanvasHeight * aspectRatio;

        if (newCanvasWidth > windowWidth * 0.95) {
          newCanvasWidth = windowWidth * 0.95;
          newCanvasHeight = newCanvasWidth / aspectRatio;
        }

        const oldCanvasWidth = canvas.width;
        const scaleRatio = newCanvasWidth / oldCanvasWidth;

        canvas.width = newCanvasWidth;
        canvas.height = newCanvasHeight;
        canvasWidth = newCanvasWidth;
        canvasHeight = newCanvasHeight;
        UI_AREA_HEIGHT = canvas.height * 0.15;

        brickSize = canvas.width / BRICK_COLUMNS;
        ballRadius = (canvas.height - UI_AREA_HEIGHT) / 100;
        launchPosition.x = canvas.width / 2;
        launchPosition.y = canvas.height - UI_AREA_HEIGHT - 30;

        if (isNaN(scaleRatio) || scaleRatio === Infinity) {
          return;
        }

        const buttonSize = canvas.width * 0.1;
        recallButton = {
          x: canvas.width / 2 - buttonSize / 2,
          y: canvas.height - buttonSize - 10,
          width: buttonSize,
          height: buttonSize,
        };

        bricks.forEach((brick) => {
          brick.x *= scaleRatio;
          brick.y *= scaleRatio;
          brick.width = brickSize - 4;
          brick.height = brickSize - 4;
        });

        balls.forEach((ball) => {
          ball.x *= scaleRatio;
          ball.y *= scaleRatio;
          ball.radius = ballRadius;
        });
      }

      const activeSoundCounts = {};
      const maxSounds = {
        bounce: 10,
        break: 8,
        default: 6,
      };

      function playSound(soundType, options = {}) {
        if (!audioCtx) return;

        const count = activeSoundCounts[soundType] || 0;
        const limit = maxSounds[soundType] || maxSounds.default;
        if (count >= limit) {
          return;
        }
        activeSoundCounts[soundType] = (activeSoundCounts[soundType] || 0) + 1;

        const now = audioCtx.currentTime;
        const masterGain = 0.15;
        let duration = 0.2;

        const gainNode = audioCtx.createGain();
        gainNode.connect(audioCtx.destination);

        const onEnded = () => {
          if (activeSoundCounts[soundType]) {
            activeSoundCounts[soundType]--;
          }
        };

        switch (soundType) {
          case "ballDestroyed": {
            const osc = audioCtx.createOscillator();
            osc.type = "triangle";
            osc.frequency.setValueAtTime(400, now);
            osc.frequency.exponentialRampToValueAtTime(100, now + 0.1);
            gainNode.gain.setValueAtTime(masterGain, now);
            gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
            osc.connect(gainNode);
            osc.start(now);
            osc.stop(now + 0.1);
            duration = 0.1;
            break;
          }
          case "bounce": {
            const osc = audioCtx.createOscillator();
            osc.type = "sine";
            osc.frequency.setValueAtTime(500 + Math.random() * 100, now);
            gainNode.gain.setValueAtTime(masterGain * 0.8, now);
            gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
            osc.connect(gainNode);
            osc.start(now);
            osc.stop(now + 0.15);
            duration = 0.15;
            break;
          }
          case "armorHit": {
            const osc = audioCtx.createOscillator();
            osc.type = "square";
            osc.frequency.setValueAtTime(120, now);
            gainNode.gain.setValueAtTime(masterGain, now);
            gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
            osc.connect(gainNode);
            osc.start(now);
            osc.stop(now + 0.1);
            duration = 0.1;
            break;
          }
          case "break": {
            const osc = audioCtx.createOscillator();
            osc.type = "triangle";
            const freq = 500;
            osc.frequency.setValueAtTime(freq + Math.random() * 50, now);
            osc.frequency.exponentialRampToValueAtTime(freq * 0.8, now + 0.1);
            gainNode.gain.setValueAtTime(masterGain, now);
            gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
            osc.connect(gainNode);
            osc.start(now);
            osc.stop(now + 0.1);
            duration = 0.1;
            break;
          }
          case "launch": {
            const osc = audioCtx.createOscillator();
            osc.type = "sine";
            osc.frequency.setValueAtTime(300, now);
            osc.frequency.exponentialRampToValueAtTime(150, now + 0.2);
            gainNode.gain.setValueAtTime(masterGain * 1.1, now);
            gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
            osc.connect(gainNode);
            osc.start(now);
            osc.stop(now + 0.2);
            duration = 0.2;
            break;
          }
          case "gameOver": {
            const osc = audioCtx.createOscillator();
            osc.type = "sawtooth";
            osc.frequency.setValueAtTime(200, now);
            osc.frequency.exponentialRampToValueAtTime(50, now + 1.5);
            gainNode.gain.setValueAtTime(masterGain * 1.5, now);
            gainNode.gain.exponentialRampToValueAtTime(0.001, now + 1.5);
            osc.connect(gainNode);
            osc.start(now);
            osc.stop(now + 1.5);
            duration = 1.5;
            break;
          }
          case "powerUpBounce": {
            const osc = audioCtx.createOscillator();
            osc.type = "sine";
            osc.frequency.setValueAtTime(800, now);
            gainNode.gain.setValueAtTime(masterGain, now);
            gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
            osc.connect(gainNode);
            osc.start(now);
            osc.stop(now + 0.1);
            duration = 0.1;
            break;
          }
          case "verticalLaser":
          case "laser": {
            const osc = audioCtx.createOscillator();
            osc.type = "sawtooth";
            osc.frequency.setValueAtTime(1000, now);
            osc.frequency.exponentialRampToValueAtTime(300, now + 0.15);
            const noiseBuffer = audioCtx.createBuffer(
              1,
              audioCtx.sampleRate * 0.1,
              audioCtx.sampleRate
            );
            const data = noiseBuffer.getChannelData(0);
            for (let i = 0; i < data.length; i++) {
              data[i] = Math.random() * 2 - 1;
            }
            const noiseSource = audioCtx.createBufferSource();
            noiseSource.buffer = noiseBuffer;
            noiseSource.connect(gainNode);
            noiseSource.start(now);
            noiseSource.stop(now + 0.1);
            gainNode.gain.setValueAtTime(masterGain, now);
            gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
            osc.connect(gainNode);
            osc.start(now);
            osc.stop(now + 0.15);
            duration = 0.15;
            break;
          }
          case "powerUp": {
            const osc = audioCtx.createOscillator();
            osc.type = "sine";
            osc.frequency.setValueAtTime(600, now);
            osc.frequency.exponentialRampToValueAtTime(900, now + 0.1);
            gainNode.gain.setValueAtTime(masterGain * 1.2, now);
            gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
            osc.connect(gainNode);
            osc.start(now);
            osc.stop(now + 0.2);
            duration = 0.2;
            break;
          }
          case "fireExplosion": {
            const bufferSize = audioCtx.sampleRate * 0.2;
            const buffer = audioCtx.createBuffer(
              1,
              bufferSize,
              audioCtx.sampleRate
            );
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
              data[i] = (Math.random() * 2 - 1) * (1 - i / bufferSize);
            }
            const noise = audioCtx.createBufferSource();
            noise.buffer = buffer;
            const bqFilter = audioCtx.createBiquadFilter();
            bqFilter.type = "lowpass";
            bqFilter.frequency.setValueAtTime(1000, now);
            bqFilter.Q.setValueAtTime(5, now);
            noise.connect(bqFilter);
            bqFilter.connect(gainNode);
            gainNode.gain.setValueAtTime(masterGain * 2.0, now);
            gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
            noise.start(now);
            noise.stop(now + 0.2);
            duration = 0.2;
            break;
          }
          default:
            setTimeout(onEnded, 10);
            return;
        }
        setTimeout(onEnded, duration * 1000);
      }

      class Ball {
        constructor(x, y, angle) {
          this.id = ballIdCounter++;
          this.x = x;
          this.y = y;
          this.speed = canvas.height / 50;
          this.vx = Math.cos(angle) * this.speed;
          this.vy = Math.sin(angle) * this.speed;
          this.radius = ballRadius;
          this.color = "#00BFFF";
          this.trail = [];
          this.rippleTimer = 0;
          this.activatedLasersThisFlight = [];
          this.isBeingRecalled = false;
        }

        draw() {
          this.trail.forEach((pos, index) => {
            const progress = index / this.trail.length;
            const opacity = progress * 0.6;
            ctx.beginPath();
            ctx.fillStyle = `rgba(0,191,255,${opacity})`;
            ctx.arc(pos.x, pos.y, this.radius * progress, 0, Math.PI * 2);
            ctx.fill();
          });

          ctx.save();
          ctx.translate(this.x, this.y);
          const speedRatio = Math.min(
            1.5,
            Math.hypot(this.vx, this.vy) / (this.speed * 0.8)
          );
          const stretchFactor = 1 + (speedRatio - 1) * 0.2;
          const squashFactor = 1 / stretchFactor;
          const angle = Math.atan2(this.vy, this.vx);
          ctx.rotate(angle);
          ctx.scale(stretchFactor, squashFactor);
          ctx.beginPath();
          ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
          ctx.fillStyle = this.color;
          ctx.fill();
          ctx.restore();
        }

        update(deltaFactor, deltaTime) {
          if (this.isBeingRecalled) {
            this.y += this.vy * deltaFactor;
            return this.y < canvas.height;
          }

          this.trail.push({ x: this.x, y: this.y });
          if (this.trail.length > NORMAL_BALL_TRAIL_LENGTH) {
            this.trail.shift();
          }

          this.x += this.vx * deltaFactor;
          this.y += this.vy * deltaFactor;

          let bounced = false;
          if (
            this.x - this.radius <= 0 ||
            this.x + this.radius >= canvas.width
          ) {
            this.vx *= -1;
            this.x =
              this.x - this.radius <= 0
                ? this.radius
                : canvas.width - this.radius;
            bounced = true;
          }

          if (this.y - this.radius <= 0) {
            this.vy *= -1;
            this.y = this.radius;
            bounced = true;
          }

          if (bounced) {
            playSound("bounce");
            shakeScreen(2);
            this.activatedLasersThisFlight = [];
          }
          return this.y <= canvas.height - UI_AREA_HEIGHT;
        }
      }

      class Brick {
        constructor(x, y, health, shape = "square") {
          this.x = x;
          this.y = y;
          this.width = brickSize - 4;
          this.height = brickSize - 4;
          this.health = health;
          this.initialHealth = health;
          this.hitAnimation = 0;
          this.isBeingDestroyed = false;
          this.destructionTimer = 0;
          this.targetY = y;
          this.shape = shape;
        }

        update(deltaTime) {
          if (this.y < this.targetY) {
            const moveSpeed = brickSize * 8 * (deltaTime / 1000);
            this.y += moveSpeed;
            if (this.y >= this.targetY) {
              this.y = this.targetY;
            }
          }

          if (this.destructionTimer > 0) {
            this.destructionTimer -= deltaTime;
            if (this.destructionTimer <= 0) {
              this.isFullyDestroyed = true;
            }
          }
          if (this.hitAnimation > 0) {
            this.hitAnimation -= deltaTime;
          }
        }

        draw() {
          if (this.isBeingDestroyed) {
            const progress = Math.max(0, this.destructionTimer / 250);
            const scale = progress;
            const alpha = progress;

            ctx.save();
            ctx.translate(this.x + this.width / 2, this.y + this.height / 2);
            ctx.scale(scale, scale);
            ctx.globalAlpha = alpha;
            ctx.translate(
              -(this.x + this.width / 2),
              -(this.y + this.height / 2)
            );
            this.drawContent();
            ctx.restore();
            return;
          }

          ctx.save();
          if (this.hitAnimation > 0) {
            const scale =
              1 + Math.sin((1 - this.hitAnimation / 170) * Math.PI) * 0.1;
            ctx.translate(this.x + this.width / 2, this.y + this.height / 2);
            ctx.scale(scale, scale);
            ctx.translate(
              -(this.x + this.width / 2),
              -(this.y + this.height / 2)
            );
          }

          this.drawContent();

          if (this.hitAnimation > 0) {
            const flashAlpha = (this.hitAnimation / 170) * 0.5;
            ctx.fillStyle = `rgba(255, 255, 255, ${flashAlpha})`;

            ctx.beginPath();
            switch (this.shape) {
              case "triangle_tl":
                ctx.moveTo(this.x, this.y);
                ctx.lineTo(this.x + this.width, this.y);
                ctx.lineTo(this.x, this.y + this.height);
                break;
              case "triangle_tr":
                ctx.moveTo(this.x, this.y);
                ctx.lineTo(this.x + this.width, this.y);
                ctx.lineTo(this.x + this.width, this.y + this.height);
                break;
              case "triangle_bl":
                ctx.moveTo(this.x, this.y);
                ctx.lineTo(this.x, this.y + this.height);
                ctx.lineTo(this.x + this.width, this.y + this.height);
                break;
              case "triangle_br":
                ctx.moveTo(this.x + this.width, this.y);
                ctx.lineTo(this.x + this.width, this.y + this.height);
                ctx.lineTo(this.x, this.y + this.height);
                break;
              default:
                ctx.rect(this.x, this.y, this.width, this.height);
                break;
            }
            ctx.closePath();
            ctx.fill();
          }
          ctx.restore();
        }

        drawContent() {
          const hue = (this.initialHealth * 12) % 360;
          const saturation = 90 - Math.min(this.initialHealth / 2, 40);
          const lightness = 60 - Math.min(this.initialHealth / 5, 20);
          let color = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
          ctx.fillStyle = color;

          ctx.beginPath();
          switch (this.shape) {
            case "triangle_tl":
              ctx.moveTo(this.x, this.y);
              ctx.lineTo(this.x + this.width, this.y);
              ctx.lineTo(this.x, this.y + this.height);
              break;
            case "triangle_tr":
              ctx.moveTo(this.x, this.y);
              ctx.lineTo(this.x + this.width, this.y);
              ctx.lineTo(this.x + this.width, this.y + this.height);
              break;
            case "triangle_bl":
              ctx.moveTo(this.x, this.y);
              ctx.lineTo(this.x, this.y + this.height);
              ctx.lineTo(this.x + this.width, this.y + this.height);
              break;
            case "triangle_br":
              ctx.moveTo(this.x + this.width, this.y);
              ctx.lineTo(this.x + this.width, this.y + this.height);
              ctx.lineTo(this.x, this.y + this.height);
              break;
            default:
              ctx.rect(this.x, this.y, this.width, this.height);
              break;
          }
          ctx.closePath();
          ctx.fill();

          let textX = this.x + this.width / 2;
          let textY = this.y + this.height / 2;
          if (this.shape.startsWith("triangle")) {
            const offset = this.width / 6;
            if (this.shape.includes("_tl")) {
              textX -= offset;
              textY -= offset;
            } else if (this.shape.includes("_tr")) {
              textX += offset;
              textY -= offset;
            } else if (this.shape.includes("_bl")) {
              textX -= offset;
              textY += offset;
            } else if (this.shape.includes("_br")) {
              textX += offset;
              textY += offset;
            }
          }

          const textContent = this.health > 0 ? this.health : "";
          ctx.font = `bold ${brickSize / 3.5}px 'Segoe UI', sans-serif`;
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.strokeStyle = "rgba(0, 0, 0, 0.8)";
          ctx.lineWidth = brickSize / 14;
          ctx.lineJoin = "round";
          ctx.strokeText(textContent, textX, textY);
          ctx.fillStyle = "white";
          ctx.fillText(textContent, textX, textY);
        }

        hit() {
          if (this.isBeingDestroyed || this.health <= 0) return;

          this.health -= BALL_DAMAGE;
          this.hitAnimation = 170;
          shakeScreen(4);

          if (this.health <= 0) {
            this.handleDestruction();
          } else {
            playSound("bounce");
          }
        }

        handleDestruction() {
          const hue = (this.initialHealth * 12) % 360;
          this.isBeingDestroyed = true;
          this.destructionTimer = 250;
          score += this.initialHealth;
          playSound("break");
          createParticles(0, 0, 40, `hsl(${hue}, 100%, 70%)`, this);
        }
      }

      class PowerUp {
        constructor(x, y, type) {
          this.id = powerUpIdCounter++;
          this.x = x;
          this.y = y;
          this.type = type;
          this.width = brickSize - 4;
          this.height = brickSize - 4;
          this.radius = (this.width / 2) * 0.8;
          this.targetY = y;
          this.pulse = Math.random() * Math.PI * 2;
        }

        update(deltaTime) {
          if (this.y < this.targetY) {
            const moveSpeed = brickSize * 8 * (deltaTime / 1000);
            this.y += moveSpeed;
            if (this.y >= this.targetY) {
              this.y = this.targetY;
            }
          }
          this.pulse += deltaTime / 400;
        }

        draw() {
          const centerX = this.x + this.width / 2;
          const centerY = this.y + this.height / 2;
          const pulseFactor = 1 + Math.sin(this.pulse) * 0.1;
          const currentRadius = this.radius * pulseFactor;

          ctx.save();
          ctx.globalAlpha = 0.85 + Math.sin(this.pulse) * 0.15;

          if (this.type === "addBall") {
            const grad = ctx.createRadialGradient(
              centerX,
              centerY,
              0,
              centerX,
              centerY,
              currentRadius
            );
            grad.addColorStop(0, "rgba(46, 204, 113, 0.7)");
            grad.addColorStop(1, "rgba(46, 204, 113, 0)");
            ctx.fillStyle = grad;
            ctx.beginPath();
            ctx.arc(centerX, centerY, currentRadius * 1.5, 0, Math.PI * 2);
            ctx.fill();

            ctx.beginPath();
            ctx.arc(centerX, centerY, currentRadius, 0, Math.PI * 2);
            ctx.strokeStyle = "#2ECC71";
            ctx.lineWidth = 3;
            ctx.stroke();

            ctx.strokeStyle = "#FFFFFF";
            ctx.lineWidth = 4;
            ctx.lineCap = "round";
            ctx.beginPath();
            const plusSize = currentRadius * 0.5;
            ctx.moveTo(centerX - plusSize, centerY);
            ctx.lineTo(centerX + plusSize, centerY);
            ctx.moveTo(centerX, centerY - plusSize);
            ctx.lineTo(centerX, centerY + plusSize);
            ctx.stroke();
          } else if (this.type === "laser" || this.type === "verticalLaser") {
            const color = this.type === "laser" ? "#3498DB" : "#9B59B6";
            const gradColor =
              this.type === "laser"
                ? "rgba(52, 152, 219, 0.7)"
                : "rgba(155, 89, 182, 0.7)";

            const grad = ctx.createRadialGradient(
              centerX,
              centerY,
              0,
              centerX,
              centerY,
              currentRadius
            );
            grad.addColorStop(0, gradColor);
            grad.addColorStop(1, "rgba(0,0,0,0)");
            ctx.fillStyle = grad;
            ctx.beginPath();
            ctx.arc(centerX, centerY, currentRadius * 1.5, 0, Math.PI * 2);
            ctx.fill();

            ctx.beginPath();
            ctx.arc(centerX, centerY, currentRadius, 0, Math.PI * 2);
            ctx.strokeStyle = color;
            ctx.lineWidth = 3;
            ctx.stroke();

            ctx.strokeStyle = "#FFFFFF";
            ctx.lineWidth = 4;
            ctx.lineCap = "round";
            ctx.beginPath();
            const lineSize = currentRadius * 0.6;
            const arrowSize = lineSize * 0.4;
            if (this.type === "laser") {
              ctx.moveTo(centerX - lineSize, centerY);
              ctx.lineTo(centerX + lineSize, centerY);
              ctx.moveTo(centerX - lineSize, centerY);
              ctx.lineTo(centerX - lineSize + arrowSize, centerY - arrowSize);
              ctx.moveTo(centerX - lineSize, centerY);
              ctx.lineTo(centerX - lineSize + arrowSize, centerY + arrowSize);
              ctx.moveTo(centerX + lineSize, centerY);
              ctx.lineTo(centerX + lineSize - arrowSize, centerY - arrowSize);
              ctx.moveTo(centerX + lineSize, centerY);
              ctx.lineTo(centerX + lineSize - arrowSize, centerY + arrowSize);
            } else {
              ctx.moveTo(centerX, centerY - lineSize);
              ctx.lineTo(centerX, centerY + lineSize);
              ctx.moveTo(centerX, centerY - lineSize);
              ctx.lineTo(centerX - arrowSize, centerY - lineSize + arrowSize);
              ctx.moveTo(centerX, centerY - lineSize);
              ctx.lineTo(centerX + arrowSize, centerY - lineSize + arrowSize);
              ctx.moveTo(centerX, centerY + lineSize);
              ctx.lineTo(centerX - arrowSize, centerY + lineSize - arrowSize);
              ctx.moveTo(centerX, centerY + lineSize);
              ctx.lineTo(centerX + arrowSize, centerY + lineSize - arrowSize);
            }
            ctx.stroke();
          } else if (this.type === "bouncer") {
            const color = "#E91E63";
            const gradColor = "rgba(233, 30, 99, 0.7)";

            const grad = ctx.createRadialGradient(
              centerX,
              centerY,
              0,
              centerX,
              centerY,
              currentRadius
            );
            grad.addColorStop(0, gradColor);
            grad.addColorStop(1, "rgba(0,0,0,0)");
            ctx.fillStyle = grad;
            ctx.beginPath();
            ctx.arc(centerX, centerY, currentRadius * 1.5, 0, Math.PI * 2);
            ctx.fill();

            ctx.beginPath();
            ctx.arc(centerX, centerY, currentRadius, 0, Math.PI * 2);
            ctx.strokeStyle = color;
            ctx.lineWidth = 3;
            ctx.stroke();

            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(centerX, centerY, currentRadius * 0.3, 0, Math.PI * 2);
            ctx.fill();

            for (let i = 0; i < 3; i++) {
              const angle = -Math.PI / 2 + (i - 1) * (Math.PI / 4);
              const arrowLength = currentRadius * 0.5;
              const arrowTipX =
                centerX + Math.cos(angle) * (currentRadius * 0.7);
              const arrowTipY =
                centerY + Math.sin(angle) * (currentRadius * 0.7);
              const arrowBaseX =
                centerX + Math.cos(angle) * (currentRadius * 0.4);
              const arrowBaseY =
                centerY + Math.sin(angle) * (currentRadius * 0.4);

              ctx.strokeStyle = "#FFFFFF";
              ctx.lineWidth = 4;
              ctx.lineCap = "round";
              ctx.beginPath();
              ctx.moveTo(arrowBaseX, arrowBaseY);
              ctx.lineTo(arrowTipX, arrowTipY);
              const arrowSize = arrowLength * 0.5;
              ctx.lineTo(
                arrowTipX - Math.cos(angle - Math.PI / 6) * arrowSize,
                arrowTipY - Math.sin(angle - Math.PI / 6) * arrowSize
              );
              ctx.moveTo(arrowTipX, arrowTipY);
              ctx.lineTo(
                arrowTipX - Math.cos(angle + Math.PI / 6) * arrowSize,
                arrowTipY - Math.sin(angle + Math.PI / 6) * arrowSize
              );
              ctx.stroke();
            }
          }

          ctx.restore();
        }
      }

      class FloatingText {
        constructor(x, y, text, color = "white", size = 20, duration = 1000) {
          this.x = x;
          this.y = y;
          this.text = text;
          this.color = color;
          this.size = size;
          this.alpha = 1;
          this.vy = -60;
          this.duration = duration;
        }

        update(deltaTime) {
          this.y += this.vy * (deltaTime / 1000);
          this.duration -= deltaTime;
          if (this.duration < 500) {
            this.alpha = this.duration / 500;
          }
        }

        draw() {
          ctx.save();
          ctx.globalAlpha = this.alpha;
          ctx.fillStyle = this.color;
          ctx.font = `bold ${this.size}px 'Segoe UI', sans-serif`;
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.shadowColor = "rgba(0, 0, 0, 0.8)";
          ctx.shadowBlur = 8;
          ctx.lineWidth = this.size / 10;
          ctx.strokeStyle = "rgba(0,0,0,0.5)";
          ctx.strokeText(this.text, this.x, this.y);
          ctx.fillText(this.text, this.x, this.y);
          ctx.restore();
        }
      }

      class Particle {
        constructor(x, y, color) {
          this.x = x;
          this.y = y;
          this.size = Math.random() * 5 + 2;
          this.vx = (Math.random() - 0.5) * 350;
          this.vy = (Math.random() - 0.8) * 350;
          this.alpha = 1;
          this.color = color;
          this.gravity = 400;
          this.drag = 0.98;
        }
        update(deltaTime) {
          const deltaSeconds = deltaTime / 1000;
          this.vy += this.gravity * deltaSeconds;
          this.vx *= this.drag;
          this.x += this.vx * deltaSeconds;
          this.y += this.vy * deltaSeconds;
          this.alpha -= deltaTime / 500;
        }
        draw() {
          ctx.globalAlpha = this.alpha;
          ctx.fillStyle = this.color;
          ctx.fillRect(this.x, this.y, this.size, this.size);
          ctx.globalAlpha = 1;
        }
      }

      function updateLaunchQueue() {
        currentLaunchQueue = [];
        for (let i = 0; i < ballsToLaunch; i++) {
          currentLaunchQueue.push({});
        }
      }

      function launchBalls() {
        firstBallReturnedThisRound = false;
        ballsReturned = 0;
        totalBallsLaunchedThisRound = currentLaunchQueue.length;
        launchIndex = 0;
        launchTimer = 0;
      }

      function nextRound() {
        wave++;
        waveCountSinceLastPowerUp++;
        screenShake.duration = 0;

        bricks.forEach((brick) => {
          brick.targetY = brick.y + brickSize;
          brick.hitAnimation = 0;
        });
        powerUps.forEach((p) => {
          p.targetY = p.y + brickSize;
        });

        if (
          bricks.some(
            (brick) => brick.targetY + brick.height >= launchPosition.y - 20
          )
        ) {
          gameState = "gameOver";
          playSound("gameOver");
          return;
        }

        generateRows();

        launchPosition.x = nextLaunchPositionX;
        updateLaunchQueue();
        gameState = "bricksMoving";
      }

      function checkCollisions() {
        for (let i = balls.length - 1; i >= 0; i--) {
          const ball = balls[i];
          let hasCollidedThisFrame = false;

          for (let j = bricks.length - 1; j >= 0; j--) {
            const brick = bricks[j];
            if (brick.isBeingDestroyed) continue;

            const closestX = Math.max(
              brick.x,
              Math.min(ball.x, brick.x + brick.width)
            );
            const closestY = Math.max(
              brick.y,
              Math.min(ball.y, brick.y + brick.height)
            );

            if (
              Math.hypot(ball.x - closestX, ball.y - closestY) < ball.radius
            ) {
              let pointIsValid = true;
              if (brick.shape !== "square") {
                const relX = closestX - brick.x;
                const relY = closestY - brick.y;
                const w = brick.width;
                switch (brick.shape) {
                  case "triangle_tl":
                    if (relX + relY > w) pointIsValid = false;
                    break;
                  case "triangle_tr":
                    if (relY > relX) pointIsValid = false;
                    break;
                  case "triangle_bl":
                    if (relY < relX) pointIsValid = false;
                    break;
                  case "triangle_br":
                    if (relX + relY < w) pointIsValid = false;
                    break;
                }
              }
              if (!pointIsValid) continue;
              if (hasCollidedThisFrame) continue;
              hasCollidedThisFrame = true;

              let onHypotenuse = false;
              if (brick.shape !== "square") {
                const epsilon = 1;
                if (
                  closestX > brick.x + epsilon &&
                  closestX < brick.x + brick.width - epsilon &&
                  closestY > brick.y + epsilon &&
                  closestY < brick.y + brick.height - epsilon
                ) {
                  onHypotenuse = true;
                }
              }

              if (onHypotenuse) {
                let slope =
                  brick.shape === "triangle_tr" || brick.shape === "triangle_bl"
                    ? 1
                    : -1;
                const normal = { x: -slope, y: 1 };
                const len = Math.hypot(normal.x, normal.y);
                normal.x /= len;
                normal.y /= len;

                const dot = ball.vx * normal.x + ball.vy * normal.y;
                ball.vx -= 2 * dot * normal.x;
                ball.vy -= 2 * dot * normal.y;
              } else {
                if (Math.abs(ball.x - closestX) > Math.abs(ball.y - closestY)) {
                  ball.vx *= -1;
                } else if (
                  Math.abs(ball.y - closestY) > Math.abs(ball.x - closestX)
                ) {
                  ball.vy *= -1;
                } else {
                  ball.vx *= -1;
                  ball.vy *= -1;
                }
              }

              ball.x += ball.vx * 0.1;
              ball.y += ball.vy * 0.1;
              ball.activatedLasersThisFlight = [];

              brick.hit();
              break;
            }
          }
        }
      }

      function generateRows() {
        let allCols = [];
        for (let c = 0; c < BRICK_COLUMNS; c++) {
          allCols.push(c);
        }

        const brickCount = Math.floor(
          Math.random() * (BRICK_COLUMNS / 2) + BRICK_COLUMNS / 3
        );
        const occupiedCols = [];
        for (let i = 0; i < brickCount; i++) {
          const randIndex = Math.floor(Math.random() * allCols.length);
          occupiedCols.push(allCols.splice(randIndex, 1)[0]);
        }

        const POWERUP_SPAWN_INTERVAL = 2;
        if (
          waveCountSinceLastPowerUp >= POWERUP_SPAWN_INTERVAL &&
          occupiedCols.length > 0
        ) {
          let type;
          const rand = Math.random();
          if (rand < 0.45) {
            type = "addBall";
          } else if (rand < 0.8) {
            type = "bouncer";
          } else if (rand < 0.9) {
            type = "laser";
          } else {
            type = "verticalLaser";
          }

          const powerUpIndex = Math.floor(Math.random() * occupiedCols.length);
          const col = occupiedCols.splice(powerUpIndex, 1)[0];
          const newPowerUp = new PowerUp(
            col * brickSize + 2,
            -brickSize + 2,
            type
          );
          newPowerUp.targetY = 2;
          powerUps.push(newPowerUp);
          waveCountSinceLastPowerUp = 0;
        }

        const occupiedColsSet = new Set(occupiedCols);
        for (const col of occupiedCols) {
          let shape = "square";
          const hasLeftNeighbor = occupiedColsSet.has(col - 1);
          const hasRightNeighbor = occupiedColsSet.has(col + 1);
          const isEdge =
            (hasLeftNeighbor && !hasRightNeighbor) ||
            (!hasLeftNeighbor && hasRightNeighbor);

          if (isEdge && Math.random() < 0.4) {
            if (hasLeftNeighbor) {
              const shapes = ["triangle_tl", "triangle_bl"];
              shape = shapes[Math.floor(Math.random() * shapes.length)];
            } else {
              const shapes = ["triangle_tr", "triangle_br"];
              shape = shapes[Math.floor(Math.random() * shapes.length)];
            }
          }

          const newBrick = new Brick(
            col * brickSize + 2,
            -brickSize + 2,
            wave,
            shape
          );
          newBrick.targetY = 2;
          bricks.push(newBrick);
        }
      }
      function startGame() {
        wave = 0;
        score = 0;
        ballsToLaunch = 1;
        launchIndex = 0;
        launchTimer = 0;
        ballsReturned = 0;
        totalBallsLaunchedThisRound = 0;
        bricks = [];
        balls = [];
        powerUps = [];
        uiButtons = [];
        visualEffects = [];
        startTime = Date.now();
        totalPausedTime = 0;
        pauseStartTime = 0;
        nextLaunchPositionX = canvas.width / 2;
        waveCountSinceLastPowerUp = 0;

        const buttonSize = canvas.width * 0.08;
        const padding = canvas.width * 0.04;
        const buttonY = canvas.height * 0.085;

        gameUiButtons = [
          {
            x: padding,
            y: buttonY - buttonSize / 2,
            width: buttonSize,
            height: buttonSize,
            text: "❚❚",
            onClick: () => {
              if (gameState === "paused") unpauseGame();
              else pauseGame();
            },
          },
          {
            x: padding + buttonSize + padding / 2,
            y: buttonY - buttonSize / 2,
            width: buttonSize,
            height: buttonSize,
            text: "?",
            onClick: () => {
              console.log("Help button clicked");
            },
          },
        ];

        nextRound();
        updateLaunchQueue();
        gameState = "bricksMoving";
      }

      function drawPredictedTrajectory() {
        const simBall = {
          x: launchPosition.x,
          y: launchPosition.y,
          vx: Math.cos(aimAngle) * (canvas.height / 160),
          vy: Math.sin(aimAngle) * (canvas.height / 160),
          radius: ballRadius,
        };

        const simBricks = bricks
          .filter((b) => !b.isBeingDestroyed)
          .map((b) => ({ ...b }));

        ctx.beginPath();
        ctx.setLineDash([5, 10]);
        ctx.strokeStyle = "rgba(255, 255, 255, 0.5)";
        ctx.moveTo(simBall.x, simBall.y);

        const MAX_STEPS = 1200;
        let firstBounceOccurred = false;
        const stepsAfterBounce = 15;
        let stepsDrawnAfterBounce = 0;

        for (let i = 0; i < MAX_STEPS; i++) {
          if (firstBounceOccurred) {
            stepsDrawnAfterBounce++;
            if (stepsDrawnAfterBounce > stepsAfterBounce) {
              break;
            }
          }

          simBall.x += simBall.vx;
          simBall.y += simBall.vy;
          let bouncedThisStep = false;

          if (
            simBall.x - simBall.radius <= 0 ||
            simBall.x + simBall.radius >= canvas.width
          ) {
            simBall.vx *= -1;
            bouncedThisStep = true;
          }
          if (simBall.y - simBall.radius <= 0) {
            simBall.vy *= -1;
            bouncedThisStep = true;
          }

          for (const brick of simBricks) {
            const closestX = Math.max(
              brick.x,
              Math.min(simBall.x, brick.x + brick.width)
            );
            const closestY = Math.max(
              brick.y,
              Math.min(simBall.y, brick.y + brick.height)
            );
            if (
              Math.hypot(simBall.x - closestX, simBall.y - closestY) <
              simBall.radius
            ) {
              let pointIsValid = true;
              if (brick.shape !== "square") {
                const relX = closestX - brick.x;
                const relY = closestY - brick.y;
                const w = brick.width;
                switch (brick.shape) {
                  case "triangle_tl":
                    if (relX + relY > w) pointIsValid = false;
                    break;
                  case "triangle_tr":
                    if (relY > relX) pointIsValid = false;
                    break;
                  case "triangle_bl":
                    if (relY < relX) pointIsValid = false;
                    break;
                  case "triangle_br":
                    if (relX + relY < w) pointIsValid = false;
                    break;
                }
              }
              if (!pointIsValid) continue;

              bouncedThisStep = true;
              let onHypotenuse = false;
              if (brick.shape !== "square") {
                const epsilon = 1;
                if (
                  closestX > brick.x + epsilon &&
                  closestX < brick.x + brick.width - epsilon &&
                  closestY > brick.y + epsilon &&
                  closestY < brick.y + brick.height - epsilon
                ) {
                  onHypotenuse = true;
                }
              }

              if (onHypotenuse) {
                let slope =
                  brick.shape === "triangle_tr" || brick.shape === "triangle_bl"
                    ? 1
                    : -1;
                const normal = { x: -slope, y: 1 };
                const len = Math.hypot(normal.x, normal.y);
                normal.x /= len;
                normal.y /= len;
                const dot = simBall.vx * normal.x + simBall.vy * normal.y;
                simBall.vx -= 2 * dot * normal.x;
                simBall.vy -= 2 * dot * normal.y;
              } else {
                if (
                  Math.abs(simBall.x - closestX) >
                  Math.abs(simBall.y - closestY)
                ) {
                  simBall.vx *= -1;
                } else {
                  simBall.vy *= -1;
                }
              }
              break;
            }
          }

          ctx.lineTo(simBall.x, simBall.y);

          if (bouncedThisStep && !firstBounceOccurred) {
            firstBounceOccurred = true;
          }

          if (simBall.y > canvas.height - UI_AREA_HEIGHT) {
            break;
          }
        }
        ctx.stroke();
        ctx.setLineDash([]);
      }

      function createParticles(x, y, count, color = null, brick = null) {
        if (!brick) {
          for (let i = 0; i < count; i++) {
            const particleColor =
              color || `hsl(${Math.random() * 360}, 100%, 70%)`;
            particles.push(new Particle(x, y, particleColor));
          }
          return;
        }

        for (let i = 0; i < count; i++) {
          let px, py;
          const shape = brick.shape;
          const bx = brick.x;
          const by = brick.y;
          const bw = brick.width;
          const bh = brick.height;
          let p1, p2, p3;

          if (shape === "square") {
            const perimeter = 2 * (bw + bh);
            let dist = Math.random() * perimeter;
            if (dist < bw) {
              px = bx + dist;
              py = by;
            } else if (dist < bw + bh) {
              px = bx + bw;
              py = by + (dist - bw);
            } else if (dist < 2 * bw + bh) {
              px = bx + (bw - (dist - (bw + bh)));
              py = by + bh;
            } else {
              px = bx;
              py = by + (bh - (dist - (2 * bw + bh)));
            }
          } else {
            switch (shape) {
              case "triangle_tl":
                p1 = { x: bx, y: by };
                p2 = { x: bx + bw, y: by };
                p3 = { x: bx, y: by + bh };
                break;
              case "triangle_tr":
                p1 = { x: bx, y: by };
                p2 = { x: bx + bw, y: by };
                p3 = { x: bx + bw, y: by + bh };
                break;
              case "triangle_bl":
                p1 = { x: bx, y: by };
                p2 = { x: bx, y: by + bh };
                p3 = { x: bx + bw, y: by + bh };
                break;
              case "triangle_br":
                p1 = { x: bx + bw, y: by };
                p2 = { x: bx + bw, y: by + bh };
                p3 = { x: bx, y: by + bh };
                break;
            }
            const l1 = Math.hypot(p2.x - p1.x, p2.y - p1.y);
            const l2 = Math.hypot(p3.x - p2.x, p3.y - p2.y);
            const l3 = Math.hypot(p1.x - p3.x, p1.y - p3.y);
            const perimeter = l1 + l2 + l3;
            let dist = Math.random() * perimeter;

            if (dist < l1) {
              const ratio = dist / l1;
              px = p1.x + (p2.x - p1.x) * ratio;
              py = p1.y + (p2.y - p1.y) * ratio;
            } else if (dist < l1 + l2) {
              const ratio = (dist - l1) / l2;
              px = p2.x + (p3.x - p2.x) * ratio;
              py = p2.y + (p3.y - p2.y) * ratio;
            } else {
              const ratio = (dist - l1 - l2) / l3;
              px = p3.x + (p1.x - p3.x) * ratio;
              py = p3.y + (p1.y - p3.y) * ratio;
            }
          }
          const particleColor =
            color || `hsl(${Math.random() * 360}, 100%, 70%)`;
          particles.push(new Particle(px, py, particleColor));
        }
      }

      function shakeScreen(intensity) {
        screenShake.intensity = intensity;
        screenShake.duration = 170;
      }

      function update(deltaTime) {
        if (!deltaTime) return;

        if (gameState === "gameOver" || gameState === "paused") {
          uiButtons.forEach((el) => {
            if (el.hoverProgress === undefined) el.hoverProgress = 0;
            const targetHover = el.isHovered ? 1 : 0;
            el.hoverProgress += (targetHover - el.hoverProgress) * 0.2;
            if (Math.abs(targetHover - el.hoverProgress) < 0.001)
              el.hoverProgress = targetHover;
            if (el.animProgress === undefined) el.animProgress = 0;
            const targetAnim = 1;
            el.animProgress += (targetAnim - el.animProgress) * 0.1;
            if (Math.abs(targetAnim - el.animProgress) < 0.001)
              el.animProgress = targetAnim;
          });
        }

        if (gameState === "paused") return;

        if (gameState === "recalling") {
          const deltaFactor = (deltaTime / (1000 / 60)) * 2;
          for (let j = balls.length - 1; j >= 0; j--) {
            if (!balls[j].update(deltaFactor, deltaTime)) {
              balls.splice(j, 1);
            }
          }
          if (balls.length === 0) {
            isSpeedingUp = false;
            isAiming = false;
            gameState = "waiting";
            setTimeout(() => nextRound(), 100);
          }
          return;
        }

        const speedMultiplier =
          isSpeedingUp && gameState === "shooting" ? SPEED_UP_MULTIPLIER : 1;
        const deltaFactor = (deltaTime / (1000 / 60)) * speedMultiplier;

        if (gameState === "shooting") {
          if (launchIndex < totalBallsLaunchedThisRound) {
            launchTimer += deltaTime;
            if (launchTimer >= LAUNCH_INTERVAL_MS) {
              launchTimer -= LAUNCH_INTERVAL_MS;
              const newBall = new Ball(
                launchPosition.x,
                launchPosition.y,
                aimAngle
              );
              balls.push(newBall);
              launchIndex++;
            }
          }

          if (bricks.length === 0 && balls.length > 0) {
            for (const ball of balls) {
              const returnSpeed = ball.speed * 1.5;
              const dx = launchPosition.x - ball.x;
              const dy = canvas.height + ball.radius - ball.y;
              const dist = Math.hypot(dx, dy);
              if (dist > 1) {
                ball.vx = (dx / dist) * returnSpeed;
                ball.vy = (dy / dist) * returnSpeed;
              }
            }
          }

          for (let j = balls.length - 1; j >= 0; j--) {
            if (!balls[j].update(deltaFactor, deltaTime)) {
              if (!firstBallReturnedThisRound) {
                nextLaunchPositionX = Math.max(
                  ballRadius,
                  Math.min(balls[j].x, canvas.width - ballRadius)
                );
                firstBallReturnedThisRound = true;
              }
              ballsReturned++;
              balls.splice(j, 1);
            }
          }

          if (bricks.length > 0) {
            checkCollisions();
          }
          checkPowerUpCollisions();

          if (
            (balls.length === 0 &&
              ballsReturned >= totalBallsLaunchedThisRound) ||
            bricks.length === 0
          ) {
            isSpeedingUp = false;
            isAiming = false;
            gameState = "waiting";
            setTimeout(() => nextRound(), 300);
          }
        }

        if (gameState === "bricksMoving") {
          let allBricksInPosition = true;
          for (const brick of bricks) {
            if (brick.y < brick.targetY) {
              allBricksInPosition = false;
              break;
            }
          }
          if (allBricksInPosition) {
            gameState = "aiming";
            launchIndex = 0;
            launchTimer = 0;
          }
        }

        bricks.forEach((b) => b.update(deltaTime));
        bricks = bricks.filter((b) => !b.isFullyDestroyed);

        powerUps.forEach((p) => p.update(deltaTime));
        powerUps = powerUps.filter((p) => p.y < canvas.height - UI_AREA_HEIGHT);

        visualEffects.forEach((effect, index) => {
          effect.duration -= deltaTime;
          if (effect.duration <= 0) {
            visualEffects.splice(index, 1);
          }
        });
        particles.forEach((p, index) => {
          p.update(deltaTime);
          if (p.alpha <= 0) particles.splice(index, 1);
        });
        floatingTexts.forEach((ft, index) => {
          ft.update(deltaTime);
          if (ft.duration <= 0) floatingTexts.splice(index, 1);
        });

        if (screenShake.duration > 0) {
          screenShake.duration -= deltaTime;
        }
      }

      function draw() {
        ctx.fillStyle = "#121212";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        const isOverlayActive =
          gameState === "gameOver" || gameState === "paused";

        ctx.save();
        if (!isOverlayActive && screenShake.duration > 0) {
          const shakeX = (Math.random() - 0.5) * screenShake.intensity;
          const shakeY = (Math.random() - 0.5) * screenShake.intensity;
          ctx.translate(shakeX, shakeY);
        }

        ctx.save();
        if (isOverlayActive) {
          ctx.filter = "blur(8px)";
        }

        ctx.translate(0, UI_AREA_HEIGHT);
        ctx.beginPath();
        ctx.rect(0, 0, canvas.width, canvas.height - UI_AREA_HEIGHT);
        ctx.clip();

        bricks.forEach((b) => b.draw());
        powerUps.forEach((p) => p.draw());
        if (gameState !== "aiming") {
          balls.forEach((b) => b.draw());
        }
        particles.forEach((p) => p.draw());
        visualEffects.forEach((effect) => {
          const progress = 1 - effect.duration / effect.initialDuration;
          const alpha = Math.sin(progress * Math.PI);
          const thickness = (1 - progress) * brickSize * 0.5 + 2;
          if (effect.type === "laser") {
            ctx.fillStyle = `rgba(52, 152, 219, ${alpha * 0.8})`;
            ctx.shadowColor = "#3498DB";
            ctx.shadowBlur = 20;
            ctx.fillRect(0, effect.y - thickness / 2, canvas.width, thickness);
          } else if (effect.type === "verticalLaser") {
            ctx.fillStyle = `rgba(155, 89, 182, ${alpha * 0.8})`;
            ctx.shadowColor = "#9B59B6";
            ctx.shadowBlur = 20;
            ctx.fillRect(
              effect.x - thickness / 2,
              0,
              thickness,
              canvas.height - UI_AREA_HEIGHT
            );
          }
          ctx.shadowBlur = 0;
        });
        floatingTexts.forEach((ft) => ft.draw());
        if (gameState === "aiming" && isAiming) {
          drawPredictedTrajectory();
        }
        if (gameState === "aiming") {
          drawBallLauncher();
        }
        ctx.restore();
        ctx.filter = "none";

        if (gameState === "shooting") {
          drawRecallButton();
        }

        drawInGameUI();

        if (gameState === "gameOver") {
          drawEndScreen();
        }
        if (gameState === "paused") {
          drawPauseScreen();
        }

        ctx.restore();
      }

      function drawRecallButton() {
        ctx.save();
        ctx.globalAlpha = 0.4;
        ctx.strokeStyle = "white";
        ctx.lineWidth = 4;
        ctx.lineCap = "round";

        const btn = recallButton;
        ctx.strokeRect(btn.x, btn.y, btn.width, btn.height);

        const margin = btn.width * 0.25;

        ctx.beginPath();
        ctx.moveTo(btn.x + margin, btn.y + margin);
        ctx.lineTo(btn.x + btn.width - margin, btn.y + btn.height - margin);
        ctx.moveTo(btn.x + btn.width - margin, btn.y + margin);
        ctx.lineTo(btn.x + margin, btn.y + btn.height - margin);
        ctx.stroke();

        ctx.restore();
      }

      function checkPowerUpCollisions() {
        for (let i = powerUps.length - 1; i >= 0; i--) {
          const p = powerUps[i];
          const centerX = p.x + p.width / 2;
          const centerY = p.y + p.height / 2;

          for (let j = balls.length - 1; j >= 0; j--) {
            const ball = balls[j];
            if (
              Math.hypot(ball.x - centerX, ball.y - centerY) <
              ball.radius + p.radius
            ) {
              if (p.type === "addBall") {
                ballsToLaunch++;
                const angle = Math.atan2(ball.vy, ball.vx);
                const newBall = new Ball(centerX, centerY, angle);
                balls.push(newBall);
                playSound("powerUp");
                floatingTexts.push(
                  new FloatingText(
                    centerX,
                    centerY,
                    "+1 Bola!",
                    "#2ECC71",
                    canvas.width / 20
                  )
                );
                powerUps.splice(i, 1);
                break;
              } else if (
                (p.type === "laser" || p.type === "verticalLaser") &&
                !ball.activatedLasersThisFlight.includes(p.id)
              ) {
                ball.activatedLasersThisFlight.push(p.id);
                playSound(p.type);
                shakeScreen(10);
                visualEffects.push({
                  type: p.type,
                  x: centerX,
                  y: centerY,
                  duration: 250,
                  initialDuration: 250,
                });
                if (p.type === "laser") {
                  bricks.forEach((brick) => {
                    if (
                      Math.abs(brick.y + brick.height / 2 - centerY) <
                      brick.height / 2
                    ) {
                      brick.hit();
                      createParticles(
                        brick.x + brick.width / 2,
                        centerY,
                        5,
                        "#FFFFFF"
                      );
                    }
                  });
                } else {
                  bricks.forEach((brick) => {
                    if (
                      Math.abs(brick.x + brick.width / 2 - centerX) <
                      brick.width / 2
                    ) {
                      brick.hit();
                      createParticles(
                        centerX,
                        brick.y + brick.height / 2,
                        5,
                        "#FFFFFF"
                      );
                    }
                  });
                }
              } else if (p.type === "bouncer") {
                const nx = ball.x - centerX;
                const ny = ball.y - centerY;
                const len = Math.hypot(nx, ny);
                const normalX = nx / len;
                const normalY = ny / len;

                const dot = ball.vx * normalX + ball.vy * normalY;
                ball.vx -= 2 * dot * normalX;
                ball.vy -= 2 * dot * normalY;

                ball.x = centerX + (p.radius + ball.radius) * normalX;
                ball.y = centerY + (p.radius + ball.radius) * normalY;

                playSound("powerUpBounce");
                createParticles(ball.x, ball.y, 10, "#E91E63");
                ball.activatedLasersThisFlight = [];
              }
            }
          }
        }
      }

      function drawRoundRect(ctx, x, y, width, height, radius) {
        if (width < 2 * radius) radius = width / 2;
        if (height < 2 * radius) radius = height / 2;
        ctx.beginPath();
        ctx.moveTo(x + radius, y);
        ctx.arcTo(x + width, y, x + width, y + height, radius);
        ctx.arcTo(x + width, y + height, x, y + height, radius);
        ctx.arcTo(x, y + height, x, y, radius);
        ctx.arcTo(x, y, x + width, y, radius);
        ctx.closePath();
        return ctx;
      }

      function drawBallLauncher() {
        const x = launchPosition.x;
        const y = launchPosition.y;
        ctx.fillStyle = "white";
        ctx.font = `bold ${canvas.width / 20}px 'Segoe UI', sans-serif`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";

        ctx.fillText("x" + ballsToLaunch, x, y - 35);

        ctx.beginPath();
        ctx.arc(x, y, ballRadius, 0, Math.PI * 2);
        ctx.fillStyle = "#00BFFF";
        ctx.fill();
      }

      function drawEndScreen() {
        ctx.filter = "blur(8px)";
        ctx.drawImage(
          canvas,
          0,
          0,
          canvas.width,
          canvas.height,
          0,
          0,
          canvas.width,
          canvas.height
        );
        ctx.filter = "none";

        const animProgress = uiButtons[0]?.animProgress || 0;

        ctx.save();
        ctx.globalAlpha = animProgress;
        ctx.translate(0, (1 - animProgress) * 50);

        const panelHeight = canvas.height * 0.55;
        const panelWidth = canvas.width * 0.85;
        const panelX = (canvas.width - panelWidth) / 2;
        const panelY = (canvas.height - panelHeight) / 2;

        const panelGrad = ctx.createLinearGradient(
          0,
          panelY,
          0,
          panelY + panelHeight
        );
        panelGrad.addColorStop(0, "rgba(45, 45, 65, 0.9)");
        panelGrad.addColorStop(1, "rgba(25, 25, 45, 0.9)");
        ctx.fillStyle = panelGrad;
        drawRoundRect(ctx, panelX, panelY, panelWidth, panelHeight, 20).fill();
        ctx.strokeStyle = "rgba(255, 69, 0, 0.5)";
        ctx.lineWidth = 2;
        drawRoundRect(
          ctx,
          panelX,
          panelY,
          panelWidth,
          panelHeight,
          20
        ).stroke();

        let titleText = "GAME OVER";
        ctx.fillStyle = "#FF4500";
        ctx.font = `bold ${canvas.width / 12}px 'Segoe UI', sans-serif`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.shadowColor = "black";
        ctx.shadowBlur = 8;
        ctx.fillText(titleText, canvas.width / 2, panelY + panelHeight * 0.2);
        ctx.shadowBlur = 0;

        let currentY = panelY + panelHeight * 0.45;
        ctx.fillStyle = "white";
        ctx.font = `bold ${canvas.width / 24}px 'Segoe UI', sans-serif`;
        ctx.fillText(`Pontuação: ${score}`, canvas.width / 2, currentY);
        ctx.restore();

        if (uiButtons.length === 0) {
          const buttonHeight =
            panelHeight * 0.15 > 55 ? 55 : panelHeight * 0.15;
          const buttonWidth = panelWidth * 0.7;
          const buttonX = panelX + (panelWidth - buttonWidth) / 2;
          let buttonY = panelY + panelHeight - buttonHeight - panelHeight * 0.1;
          let buttonConfig = {
            text: "Tentar Novamente",
            color: "#FF4500",
            onClick: () => window.location.reload(),
          };
          uiButtons.push({
            x: buttonX,
            y: buttonY,
            width: buttonWidth,
            height: buttonHeight,
            ...buttonConfig,
          });
        }

        uiButtons.forEach((button) => {
          const hoverProgress = button.hoverProgress || 0;
          const scale = 1 + hoverProgress * 0.03;

          ctx.save();
          ctx.globalAlpha = animProgress;
          ctx.translate(
            button.x + button.width / 2,
            button.y + button.height / 2
          );
          ctx.scale(scale, scale);
          ctx.translate(
            -(button.x + button.width / 2),
            -(button.y + button.height / 2)
          );
          ctx.shadowColor = button.color;
          ctx.shadowBlur = hoverProgress * 25;
          const btnGrad = ctx.createLinearGradient(
            button.x,
            button.y,
            button.x,
            button.y + button.height
          );
          btnGrad.addColorStop(0, "rgba(80, 80, 110, 0.8)");
          btnGrad.addColorStop(1, "rgba(60, 60, 90, 0.8)");
          ctx.fillStyle = btnGrad;
          drawRoundRect(
            ctx,
            button.x,
            button.y,
            button.width,
            button.height,
            12
          ).fill();
          const r = parseInt(button.color.slice(1, 3), 16);
          const g = parseInt(button.color.slice(3, 5), 16);
          const b = parseInt(button.color.slice(5, 7), 16);
          ctx.strokeStyle = `rgba(${r},${g},${b}, ${
            0.5 + hoverProgress * 0.5
          })`;
          ctx.lineWidth = 2 + hoverProgress * 1.5;
          drawRoundRect(
            ctx,
            button.x,
            button.y,
            button.width,
            button.height,
            12
          ).stroke();
          ctx.shadowBlur = 0;
          ctx.fillStyle = "white";
          ctx.font = `bold ${canvas.width / 25}px 'Segoe UI', sans-serif`;
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.shadowColor = "black";
          ctx.shadowBlur = 4;
          ctx.fillText(
            button.text,
            button.x + button.width / 2,
            button.y + button.height / 2
          );
          ctx.restore();
        });
      }

      function drawPauseScreen() {
        ctx.filter = "blur(8px)";
        ctx.drawImage(canvas, 0, 0);
        ctx.filter = "none";
        const animProgress = uiButtons[0]?.animProgress || 0;
        const panelWidth = canvas.width * 0.8;
        const panelHeight = canvas.height * 0.4;
        const panelX = (canvas.width - panelWidth) / 2;
        const panelY = (canvas.height - panelHeight) / 2;

        ctx.save();
        ctx.globalAlpha = animProgress;
        ctx.translate(panelX + panelWidth / 2, panelY + panelHeight / 2);
        ctx.scale(0.8 + animProgress * 0.2, 0.8 + animProgress * 0.2);
        ctx.translate(-(panelX + panelWidth / 2), -(panelY + panelHeight / 2));
        const panelGrad = ctx.createLinearGradient(
          0,
          panelY,
          0,
          panelY + panelHeight
        );
        panelGrad.addColorStop(0, "rgba(45, 45, 65, 0.9)");
        panelGrad.addColorStop(1, "rgba(25, 25, 45, 0.9)");
        ctx.fillStyle = panelGrad;
        drawRoundRect(ctx, panelX, panelY, panelWidth, panelHeight, 20).fill();
        ctx.strokeStyle = "rgba(255, 255, 255, 0.3)";
        ctx.lineWidth = 2;
        drawRoundRect(
          ctx,
          panelX,
          panelY,
          panelWidth,
          panelHeight,
          20
        ).stroke();
        ctx.fillStyle = "white";
        ctx.font = `bold ${canvas.width / 12}px 'Segoe UI', sans-serif`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.shadowColor = "black";
        ctx.shadowBlur = 8;
        ctx.fillText("PAUSADO", canvas.width / 2, panelY + panelHeight * 0.3);
        ctx.shadowBlur = 0;
        ctx.restore();

        if (uiButtons.length === 0) {
          const buttonWidth = panelWidth * 0.6;
          const buttonHeight = panelHeight * 0.2;
          const buttonX = panelX + (panelWidth - buttonWidth) / 2;
          const gap = panelHeight * 0.1;
          const resumeButton = {
            x: buttonX,
            y: panelY + panelHeight * 0.45,
            width: buttonWidth,
            height: buttonHeight,
            text: "Continuar",
            color: "#32CD32",
            onClick: unpauseGame,
          };
          const restartButton = {
            x: buttonX,
            y: resumeButton.y + buttonHeight + gap,
            width: buttonWidth,
            height: buttonHeight,
            text: "Reiniciar",
            color: "#FF4500",
            onClick: () => {
              window.location.reload();
            },
          };
          uiButtons.push(resumeButton, restartButton);
        }

        uiButtons.forEach((button) => {
          const hoverProgress = button.hoverProgress || 0;
          const scale = 1 + hoverProgress * 0.05;
          ctx.save();
          ctx.globalAlpha = animProgress;
          ctx.translate(
            button.x + button.width / 2,
            button.y + button.height / 2
          );
          ctx.scale(scale, scale);
          ctx.translate(
            -(button.x + button.width / 2),
            -(button.y + button.height / 2)
          );
          ctx.shadowColor = button.color;
          ctx.shadowBlur = hoverProgress * 20;
          const btnGrad = ctx.createLinearGradient(
            button.x,
            button.y,
            button.x,
            button.y + button.height
          );
          btnGrad.addColorStop(0, "rgba(80, 80, 110, 0.8)");
          btnGrad.addColorStop(1, "rgba(60, 60, 90, 0.8)");
          ctx.fillStyle = btnGrad;
          drawRoundRect(
            ctx,
            button.x,
            button.y,
            button.width,
            button.height,
            10
          ).fill();
          const r = parseInt(button.color.slice(1, 3), 16);
          const g = parseInt(button.color.slice(3, 5), 16);
          const b = parseInt(button.color.slice(5, 7), 16);
          ctx.strokeStyle = `rgba(${r},${g},${b}, ${
            0.5 + hoverProgress * 0.5
          })`;
          ctx.lineWidth = 1.5 + hoverProgress * 1.5;
          drawRoundRect(
            ctx,
            button.x,
            button.y,
            button.width,
            button.height,
            10
          ).stroke();
          ctx.fillStyle = "white";
          ctx.font = `bold ${canvas.width / 28}px 'Segoe UI', sans-serif`;
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.shadowColor = "black";
          ctx.shadowBlur = 4;
          ctx.fillText(
            button.text,
            button.x + button.width / 2,
            button.y + button.height / 2
          );
          ctx.restore();
        });
      }

      function formatTime(ms) {
        const totalSeconds = Math.floor(ms / 1000);
        const minutes = Math.floor(totalSeconds / 60)
          .toString()
          .padStart(2, "0");
        const seconds = (totalSeconds % 60).toString().padStart(2, "0");
        return `${minutes}:${seconds}`;
      }

      function drawInGameUI() {
        const uiAreaHeight = canvas.height * 0.15;
        ctx.fillStyle = "rgba(18, 18, 18, 0.9)";
        ctx.fillRect(0, 0, canvas.width, uiAreaHeight);

        const padding = canvas.width * 0.04;
        const topY = canvas.height * 0.05;
        const fontSizeLarge = canvas.width / 12;
        const fontSizeSmall = canvas.width / 25;

        ctx.textBaseline = "middle";
        ctx.fillStyle = "white";

        ctx.textAlign = "center";
        ctx.font = `bold ${fontSizeLarge}px 'Consolas', 'Courier New', monospace`;
        const timeY = topY;
        if (gameState !== "paused" && startTime > 0) {
          const elapsedTime = Date.now() - startTime - totalPausedTime;
          ctx.fillText(formatTime(elapsedTime), canvas.width / 2, timeY);
        } else {
          const lastTime =
            (pauseStartTime || Date.now()) - startTime - totalPausedTime;
          ctx.fillText(
            formatTime(lastTime > 0 ? lastTime : 0),
            canvas.width / 2,
            timeY
          );
        }

        const statsY = canvas.height * 0.11;
        ctx.font = `bold ${fontSizeSmall}px 'Consolas', 'Courier New', monospace`;

        ctx.textAlign = "center";
        gameUiButtons.forEach((button) => {
          ctx.strokeStyle = "white";
          ctx.lineWidth = 2;
          ctx.strokeRect(button.x, button.y, button.width, button.height);
          ctx.fillText(
            button.text,
            button.x + button.width / 2,
            button.y + button.height / 2
          );
        });

        ctx.textAlign = "center";
        ctx.fillText(`Onda: ${wave}`, canvas.width / 2, statsY);

        ctx.textAlign = "right";
        ctx.fillText(`Pontos: ${score}`, canvas.width - padding, statsY);
      }

      function gameLoop(currentTime) {
        if (!gameLoop.lastTime) {
          gameLoop.lastTime = currentTime;
        }
        const deltaTime = currentTime - gameLoop.lastTime;
        gameLoop.lastTime = currentTime;
        update(deltaTime);
        draw();
        requestAnimationFrame(gameLoop);
      }

      const pauseGame = () => {
        if (
          gameState !== "paused" &&
          gameState !== "gameOver" &&
          gameState !== "levelComplete"
        ) {
          previousGameState = gameState;
          gameState = "paused";
          uiButtons = [];
          isAiming = false;
          pauseStartTime = Date.now();
        }
      };

      const unpauseGame = () => {
        if (gameState === "paused") {
          gameState = previousGameState;
          uiButtons = [];
          totalPausedTime += Date.now() - pauseStartTime;
        }
      };

      function recallBalls() {
        if (gameState !== "shooting") return;
        gameState = "recalling";
        isSpeedingUp = false;
        balls.forEach((ball) => {
          ball.isBeingRecalled = true;
          ball.vx = 0;
          ball.vy = ball.speed * 2;
          ball.trail = [];
        });
      }

      function handleMouseUp(event) {
        event.preventDefault();
        const rect = canvas.getBoundingClientRect();
        let clickX, clickY;
        if (event.changedTouches) {
          clickX = event.changedTouches[0].clientX - rect.left;
          clickY = event.changedTouches[0].clientY - rect.top;
        } else {
          clickX = event.clientX - rect.left;
          clickY = event.clientY - rect.top;
        }

        if (gameState === "shooting") {
          const btn = recallButton;
          if (
            clickX >= btn.x &&
            clickX <= btn.x + btn.width &&
            clickY >= btn.y &&
            clickY <= btn.y + btn.height
          ) {
            recallBalls();
            return;
          }
        }

        let buttonsToCheck = [];
        const activeGameStates = [
          "aiming",
          "shooting",
          "bricksMoving",
          "waiting",
        ];

        if (activeGameStates.includes(gameState)) {
          buttonsToCheck = gameUiButtons;
        } else if (gameState === "paused" || gameState === "gameOver") {
          buttonsToCheck = uiButtons;
        }

        for (const button of buttonsToCheck) {
          if (
            clickX > button.x &&
            clickX < button.x + button.width &&
            clickY > button.y &&
            clickY < button.y + button.height
          ) {
            button.onClick();
            return;
          }
        }
        if (isAiming && gameState === "aiming") {
          isAiming = false;
          gameState = "shooting";
          launchBalls();
          playSound("launch");
        }
        isSpeedingUp = false;
      }

      function handleMouseDown(event) {
        event.preventDefault();
        const rect = canvas.getBoundingClientRect();
        const touch = event.touches ? event.touches[0] : event;
        const clickY = touch.clientY - rect.top;

        if (clickY < UI_AREA_HEIGHT) return;

        if (gameState === "aiming") {
          isAiming = true;
          mouse.x = touch.clientX - rect.left;
          mouse.y = clickY - UI_AREA_HEIGHT;
          const dx = mouse.x - launchPosition.x;
          const dy = mouse.y - launchPosition.y;
          aimAngle = Math.atan2(dy, dx);
          const minAngleMargin = 0.05;
          if (aimAngle > -minAngleMargin) aimAngle = -minAngleMargin;
          if (aimAngle < -Math.PI + minAngleMargin)
            aimAngle = -Math.PI + minAngleMargin;
        } else if (gameState === "shooting") {
          isSpeedingUp = true;
        }
      }

      function handleMouseMove(event) {
        event.preventDefault();
        const rect = canvas.getBoundingClientRect();
        const touch = event.touches ? event.touches[0] : event;
        const rawMouseX = touch.clientX - rect.left;
        const rawMouseY = touch.clientY - rect.top;

        const activeUIStates = ["gameOver", "paused"];
        if (activeUIStates.includes(gameState)) {
          uiButtons.forEach((el) => {
            el.isHovered =
              rawMouseX > el.x &&
              rawMouseX < el.x + el.width &&
              rawMouseY > el.y &&
              rawMouseY < el.y + el.height;
          });
        }

        if (isAiming) {
          const gameMouseY = rawMouseY - UI_AREA_HEIGHT;
          if (gameMouseY < 0) return;

          mouse.x = rawMouseX;
          mouse.y = gameMouseY;

          const dx = mouse.x - launchPosition.x;
          const dy = mouse.y - launchPosition.y;
          aimAngle = Math.atan2(dy, dx);
          const minAngleMargin = 0.05;
          if (aimAngle > -minAngleMargin) aimAngle = -minAngleMargin;
          if (aimAngle < -Math.PI + minAngleMargin)
            aimAngle = -Math.PI + minAngleMargin;
        }
      }

      canvas.addEventListener("mousedown", handleMouseDown);
      canvas.addEventListener("mousemove", handleMouseMove);
      canvas.addEventListener("mouseup", handleMouseUp);
      canvas.addEventListener("touchstart", handleMouseDown);
      canvas.addEventListener("touchmove", handleMouseMove);
      canvas.addEventListener("touchend", handleMouseUp);

      window.addEventListener("blur", pauseGame);

      window.addEventListener("keydown", (event) => {
        if (event.key === "Escape") {
          if (gameState === "paused") {
            unpauseGame();
          } else {
            pauseGame();
          }
        }
      });

      window.addEventListener("resize", resizeGame);
      resizeGame();
      startGame();
      gameLoop();
    </script>
  </body>
</html>
