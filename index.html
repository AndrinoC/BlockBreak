<!DOCTYPE html>
<html lang="pt-br">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>BlockBreaker</title>
    <style>
      body {
        background-color: #121212;
        color: #ffffff;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        height: 100vh;
        margin: 0;
        font-family: "Consolas", "Courier New", monospace;
        overflow: hidden;
      }

      canvas {
        background-color: #282828;
        border-radius: 8px;
        box-shadow: 0 0 20px rgba(255, 255, 255, 0.1);
        max-width: 100%;
        max-height: 100%;
      }

      #info {
        margin-top: 15px;
        font-size: 1.2em;
        color: #ccc;
      }
    </style>
  </head>

  <body>
    <canvas id="gameCanvas"></canvas>
    <div id="info">Clique e arraste para mirar. Solte para lançar.</div>
    <script>
      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");
      const infoDiv = document.getElementById("info");
      const aspectRatio = 9 / 16;
      let canvasHeight, canvasWidth;

      const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

      const BRICK_COLUMNS = 8;
      const SPEED_UP_MULTIPLIER = 4;
      const LAUNCH_INTERVAL_MS = 150;
      const NORMAL_BALL_TRAIL_LENGTH = 10;
      const SMALL_BALL_TRAIL_LENGTH = 4;
      let ballRadius = 8;
      let brickSize = canvas.width / BRICK_COLUMNS;
      let balls = [];
      let bricks = [];
      let powerUps = [];
      let particles = [];
      let floatingTexts = [];
      let visualEffects = [];

      let gameState = "aiming";
      let ballsToLaunch = 1;
      let ballsReturned = 0;
      let level = 0;
      let score = 0;
      let levelTargetScore = 0;
      let totalHealthGenerated = 0;
      let totalBallsLaunchedThisRound = 0;
      let rowsGeneratedThisLevel = 0;
      let aimAngle = -Math.PI / 2;
      let isAiming = false;
      let isSpeedingUp = false;
      let mouse = { x: 0, y: 0 };
      let playerPerk = null;
      let powerUpChoices = [];
      let playerDamage = 1;
      let previousGameState = "";
      let powerUpQueue = [];
      let uiButtons = [];
      let endScreenListenerAdded = false;
      let launchIndex = 0;
      let launchTimer = 0;
      let currentLaunchQueue = [];
      let backgroundMetaballs = [];
      let offscreenCanvas = document.createElement('canvas');
      let offscreenCtx = offscreenCanvas.getContext('2d');

      const levels = [
        { rows: 8, baseHealth: 15, healthIncrease: 3 },
        { rows: 12, baseHealth: 30, healthIncrease: 5 },
        { rows: 12, baseHealth: 60, healthIncrease: 10 },
        { rows: 15, baseHealth: 100, healthIncrease: 15 },
        { rows: 20, baseHealth: 150, healthIncrease: 25 },
      ];

      const powerUpDisplayNames = {
        Normal: 'Normal',
        Fire: 'Bola de Fogo',
        Giant: 'Bola Gigante',
        Scatter: 'Chuva de Bolas',
        Laser: 'Precisão Laser',
        Ghost: 'Bola Fantasma',
        Multiplier: 'Multiplicador',
        DamageUp: 'Dano Aumentado'
      };

      const launchPosition = {
        x: canvas.width / 2,
        y: canvas.height - 30,
      };

      let screenShake = {
        intensity: 0,
        duration: 0,
      };

            let backgroundColorShift = { hue: null, timer: 0 };

      function triggerBackgroundColorShift(hue) {
        backgroundColorShift.hue = hue;
        backgroundColorShift.timer = 60; // Duração do efeito em frames
      }

      function hslToRgb(h, s, l) {
        let r, g, b;
        if (s == 0) {
            r = g = b = l;
        } else {
            const hue2rgb = (p, q, t) => {
                if (t < 0) t += 1;
                if (t > 1) t -= 1;
                if (t < 1 / 6) return p + (q - p) * 6 * t;
                if (t < 1 / 2) return q;
                if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
                return p;
            };
            const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
            const p = 2 * l - q;
            r = hue2rgb(p, q, h + 1 / 3);
            g = hue2rgb(p, q, h);
            b = hue2rgb(p, q, h - 1 / 3);
        }
        return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
      }
    
          class Metaball {
        constructor() {
          this.x = Math.random() * canvas.width;
          this.y = Math.random() * canvas.height;
          this.vx = (Math.random() - 0.5) * 0.8;
          this.vy = (Math.random() - 0.5) * 0.8;
          this.radius = Math.random() * 60 + 50;
          this.friction = 0.98;
          this.maxSpeed = 2.5;
        }

        update() {
          this.vx += (Math.random() - 0.5) * 0.02;
          this.vy += (Math.random() - 0.5) * 0.02;
            
          this.vx *= this.friction;
          this.vy *= this.friction;

          const speed = Math.hypot(this.vx, this.vy);
          if (speed > this.maxSpeed) {
              const scale = this.maxSpeed / speed;
              this.vx *= scale;
              this.vy *= scale;
          }

          this.x += this.vx;
          this.y += this.vy;
          
          if (this.x - this.radius < 0) { this.x = this.radius; this.vx *= -1; }
          if (this.x + this.radius > canvas.width) { this.x = canvas.width - this.radius; this.vx *= -1; }
          if (this.y - this.radius < 0) { this.y = this.radius; this.vy *= -1; }
          if (this.y + this.radius > canvas.height) { this.y = canvas.height - this.radius; this.vy *= -1; }
        }
      }

      function setupBackground() {
          backgroundMetaballs = [];
          for(let i = 0; i < 7; i++) {
              backgroundMetaballs.push(new Metaball());
          }
          offscreenCanvas.width = canvas.width / 4;
          offscreenCanvas.height = canvas.height / 4;
      }

      function updateBackground() {
          if (backgroundColorShift.timer > 0) {
              backgroundColorShift.timer--;
          }
          backgroundMetaballs.forEach(ball => ball.update());
      }
      
      function drawBackground() {
          const width = offscreenCanvas.width;
          const height = offscreenCanvas.height;
          const scaleX = canvas.width / width;
          const scaleY = canvas.height / height;
          const imageData = offscreenCtx.getImageData(0, 0, width, height);
          const data = imageData.data;

          const baseColor = [40, 50, 120];
          let finalColor = baseColor;

          if (backgroundColorShift.timer > 0) {
              const shiftColor = hslToRgb(backgroundColorShift.hue / 360, 0.7, 0.5);
              const interpFactor = Math.sin((backgroundColorShift.timer / 60) * Math.PI);
              finalColor = [
                  baseColor[0] + (shiftColor[0] - baseColor[0]) * interpFactor,
                  baseColor[1] + (shiftColor[1] - baseColor[1]) * interpFactor,
                  baseColor[2] + (shiftColor[2] - baseColor[2]) * interpFactor,
              ];
          }
          
          for (let i = 0; i < data.length; i += 4) {
              const x = (i / 4) % width;
              const y = Math.floor((i / 4) / width);
              
              let sum = 0;
              backgroundMetaballs.forEach(ball => {
                  const dx = x * scaleX - ball.x;
                  const dy = y * scaleY - ball.y;
                  sum += (ball.radius * ball.radius) / (dx * dx + dy * dy);
              });
              
              if (sum >= 1) {
                  data[i]     = finalColor[0];
                  data[i + 1] = finalColor[1];
                  data[i + 2] = finalColor[2];
                  data[i + 3] = 255;
              } else {
                  data[i + 3] = 0;
              }
          }
          
          offscreenCtx.putImageData(imageData, 0, 0);
          ctx.globalAlpha = 0.6;
          ctx.drawImage(offscreenCanvas, 0, 0, canvas.width, canvas.height);
          ctx.globalAlpha = 1;
      }

      function createBackgroundRipple(x, y, intensity) {
        backgroundMetaballs.forEach(ball => {
            const dx = ball.x - x;
            const dy = ball.y - y;
            const dist = Math.hypot(dx, dy);
            if (dist < 250) {
                const force = (1 - (dist / 250)) * intensity;
                ball.vx += (dx / dist) * force;
                ball.vy += (dy / dist) * force;
            }
        });
      }

      function resizeGame() {
        const windowHeight = window.innerHeight;
        const windowWidth = window.innerWidth;
        let newCanvasHeight = windowHeight * 0.9;
        let newCanvasWidth = newCanvasHeight * aspectRatio;

        if (newCanvasWidth > windowWidth * 0.95) {
          newCanvasWidth = windowWidth * 0.95;
          newCanvasHeight = newCanvasWidth / aspectRatio;
        }

        const oldCanvasWidth = canvas.width;
        const scaleRatio = newCanvasWidth / oldCanvasWidth;

        canvas.width = newCanvasWidth;
        canvas.height = newCanvasHeight;
        canvasWidth = newCanvasWidth;
        canvasHeight = newCanvasHeight;

        brickSize = canvas.width / BRICK_COLUMNS;
        ballRadius = canvas.height / 100;
        launchPosition.x = canvas.width / 2;
        launchPosition.y = canvas.height - 30;

        if (
          isNaN(scaleRatio) ||
          scaleRatio === Infinity ||
          gameState === "startScreen"
        ) {
          return;
        }

        bricks.forEach((brick) => {
          brick.x *= scaleRatio;
          brick.y *= scaleRatio;
          brick.width = brickSize - 4;
          brick.height = brickSize - 4;
        });

        balls.forEach((ball) => {
          ball.x *= scaleRatio;
          ball.y *= scaleRatio;
          ball.radius = ball.isSmall ? ballRadius * 0.6 : ballRadius;
        });

        powerUps.forEach((powerUp) => {
          powerUp.x *= scaleRatio;
          powerUp.y *= scaleRatio;
        });
      }

      function playSound(soundType, options = {}) {
        if (!audioCtx) return;
        const oscillator = audioCtx.createOscillator();
        const gainNode = audioCtx.createGain();
        oscillator.connect(gainNode);
        gainNode.connect(audioCtx.destination);
        gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);

        switch (soundType) {
          case "bounce":
            oscillator.type = "sine";
            oscillator.frequency.setValueAtTime(440, audioCtx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(
              0.001,
              audioCtx.currentTime + 0.2
            );
            break;
          case "break":
            oscillator.type = "sawtooth";
            oscillator.frequency.setValueAtTime(
              options.isPowerUp ? 880 : 660,
              audioCtx.currentTime
            );
            gainNode.gain.exponentialRampToValueAtTime(
              0.001,
              audioCtx.currentTime + 0.15
            );
            break;
          case "powerup":
            oscillator.type = "triangle";
            oscillator.frequency.setValueAtTime(523, audioCtx.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(
              1046,
              audioCtx.currentTime + 0.2
            );
            gainNode.gain.exponentialRampToValueAtTime(
              0.001,
              audioCtx.currentTime + 0.3
            );
            break;
          case "launch":
            oscillator.type = "square";
            oscillator.frequency.setValueAtTime(220, audioCtx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(
              0.001,
              audioCtx.currentTime + 0.3
            );
            break;
          case "gameOver":
            oscillator.type = "sawtooth";
            oscillator.frequency.setValueAtTime(200, audioCtx.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(
              50,
              audioCtx.currentTime + 1.5
            );
            gainNode.gain.exponentialRampToValueAtTime(
              0.001,
              audioCtx.currentTime + 1.5
            );
            break;
          case "laser":
            oscillator.type = "sawtooth";
            oscillator.frequency.setValueAtTime(1200, audioCtx.currentTime);
            oscillator.frequency.linearRampToValueAtTime(
              300,
              audioCtx.currentTime + 0.5
            );
            gainNode.gain.exponentialRampToValueAtTime(
              0.001,
              audioCtx.currentTime + 0.5
            );
            break;
          case "scatter":
            oscillator.type = "triangle";
            oscillator.frequency.setValueAtTime(600, audioCtx.currentTime);
            oscillator.frequency.linearRampToValueAtTime(
              1200,
              audioCtx.currentTime + 0.1
            );
            gainNode.gain.exponentialRampToValueAtTime(
              0.001,
              audioCtx.currentTime + 0.2
            );
            break;
          case "fireExplosion":
            oscillator.type = "square";
            oscillator.frequency.setValueAtTime(150, audioCtx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(
              0.001,
              audioCtx.currentTime + 0.4
            );
            break;
          case "levelUp":
            [523.25, 659.25, 783.99].forEach((freq, index) => {
              const osc = audioCtx.createOscillator();
              const gain = audioCtx.createGain();
              osc.connect(gain);
              gain.connect(audioCtx.destination);
              const startTime = audioCtx.currentTime + 0.1 * index;
              osc.frequency.setValueAtTime(freq, startTime);
              gain.gain.setValueAtTime(0.2, startTime);
              gain.gain.exponentialRampToValueAtTime(0.001, startTime + 0.4);
              osc.start(startTime);
              osc.stop(startTime + 0.5);
            });
            return;
        }
        oscillator.start(audioCtx.currentTime);
        oscillator.stop(audioCtx.currentTime + 0.5);
      }

            class Ball {
        constructor(x, y, angle, isSmall = false, damage = playerDamage) {
          this.x = x;
          this.y = y;
          this.speed = canvas.height / 160;
          this.vx = Math.cos(angle) * this.speed;
          this.vy = Math.sin(angle) * this.speed;
          this.isSmall = isSmall;
          this.radius = isSmall ? ballRadius * 0.6 : ballRadius;
          this.color = "#00BFFF";
          this.trail = [];
          this.powerUp = null;
          this.hasScattered = false;
          this.isGhosting = false;
          this.canSplit = false;
          this.isSplitBall = false;
          this.damage = damage;
          this.timeSinceLastBrickHit = 0;
          this.rippleTimer = 0;
        }

        draw() {
          this.trail.forEach((pos, index) => {
            ctx.beginPath();
            const opacity = (index / this.trail.length) * 0.5;
            let trailColor;
            if (this.powerUp === "fire")
              trailColor = `rgba(255,69,0,${opacity})`;
            else if (this.powerUp === "giant")
              trailColor = `rgba(0,100,255,${opacity})`;
            else if (this.powerUp === "scatter")
              trailColor = `rgba(255,255,0,${opacity})`;
            else trailColor = `rgba(0,191,255,${opacity})`;

            ctx.fillStyle = trailColor;
            ctx.arc(
              pos.x,
              pos.y,
              this.radius * (index / this.trail.length),
              0,
              Math.PI * 2
            );
            ctx.fill();
          });

          ctx.save();
          ctx.translate(this.x, this.y);
          const speedRatio = Math.min(
            1.5,
            Math.hypot(this.vx, this.vy) / (this.speed * 0.8)
          );
          const stretchFactor = 1 + (speedRatio - 1) * 0.2;
          const squashFactor = 1 / stretchFactor;
          const angle = Math.atan2(this.vy, this.vx);
          ctx.rotate(angle);
          ctx.scale(stretchFactor, squashFactor);

          ctx.beginPath();
          ctx.arc(0, 0, this.radius, 0, Math.PI * 2);

          if (this.powerUp === "fire") ctx.fillStyle = "#FF4500";
          else if (this.powerUp === "giant") ctx.fillStyle = "#1E90FF";
          else if (this.powerUp === "scatter") ctx.fillStyle = "#FFFF00";
          else ctx.fillStyle = this.color;

          ctx.fill();
          ctx.restore();
        }

        update() {
          this.timeSinceLastBrickHit += 16.66;
          this.rippleTimer += 16.66;

          if (this.rippleTimer > 50) {
              createBackgroundRipple(this.x, this.y, 0.5);
              this.rippleTimer = 0;
          }

          this.trail.push({ x: this.x, y: this.y });
          const maxTrailLength = this.isSmall
            ? SMALL_BALL_TRAIL_LENGTH
            : NORMAL_BALL_TRAIL_LENGTH;
          if (this.trail.length > maxTrailLength) {
            this.trail.shift();
          }

          this.x += this.vx;
          this.y += this.vy;

          let bounced = false;
          if (this.x - this.radius <= 0 || this.x + this.radius >= canvas.width) {
            this.vx *= -1;
            this.x = this.x - this.radius <= 0 ? this.radius : canvas.width - this.radius;
            bounced = true;

            const minVerticalRatio = 0.1;
            if (Math.abs(this.vy) < this.speed * minVerticalRatio) {
              this.vy = this.speed * minVerticalRatio * (Math.sign(this.vy) || 1);
              const newSpeed = Math.hypot(this.vx, this.vy);
              const scale = this.speed / newSpeed;
              this.vx *= scale;
              this.vy *= scale;
            }
          }

          if (this.y - this.radius <= 0) {
            this.vy *= -1;
            this.y = this.radius;
            bounced = true;
          }

          if (bounced) {
            if (this.powerUp === "ghost") this.powerUp = null;
            playSound("bounce");
            shakeScreen(2);
            createBackgroundRipple(this.x, this.y, 1);
          }

          return this.y <= canvas.height;
        }
      }

      class Brick {
        constructor(x, y, health, powerUpType = null) {
          this.x = x;
          this.y = y;
          this.width = brickSize - 4;
          this.height = brickSize - 4;
          this.health = health;
          this.initialHealth = health;
          this.powerUp = powerUpType;
          this.hitAnimation = 0;
          this.isBeingDestroyed = false;
          this.destructionTimer = 0;
        }

        update() {
            if (this.destructionTimer > 0 && gameState !== "paused") {
                this.destructionTimer--;
                if (this.destructionTimer === 0) {
                    this.isFullyDestroyed = true;
                }
            }
        }

        draw() {
          if (this.isBeingDestroyed) {
            const progress = this.destructionTimer / 15;
            const scale = progress;
            const alpha = progress;
            
            ctx.save();
            ctx.translate(this.x + this.width / 2, this.y + this.height / 2);
            ctx.scale(scale, scale);
            ctx.globalAlpha = alpha;
            ctx.translate(-(this.x + this.width / 2), -(this.y + this.height / 2));
            
            this.drawContent();
            
            ctx.restore();
            return;
          }

          ctx.save();
          if (this.hitAnimation > 0) {
            const scale = 1 + Math.sin((this.hitAnimation / 5) * Math.PI) * 0.1;
            ctx.translate(this.x + this.width / 2, this.y + this.height / 2);
            ctx.scale(scale, scale);
            ctx.translate(-(this.x + this.width / 2), -(this.y + this.height / 2));
            if (gameState !== "paused") {
              this.hitAnimation--;
            }
          }
          
          this.drawContent();

          if (this.hitAnimation > 0) {
            const flashAlpha = (this.hitAnimation / 10) * 0.5;
            ctx.fillStyle = `rgba(255, 255, 255, ${flashAlpha})`;
            ctx.fillRect(this.x, this.y, this.width, this.height);
          }
          ctx.restore();
        }

        drawContent() {
          const hue = (this.initialHealth * 41) % 360;
          const color = `hsl(${hue}, 80%, 50%)`;
          ctx.fillStyle = color;
          ctx.fillRect(this.x, this.y, this.width, this.height);

          if (this.powerUp) {
            const animatedHue = (Date.now() / 10) % 360;
            ctx.fillStyle = `hsl(${animatedHue}, 90%, 60%)`;
            ctx.beginPath();
            ctx.arc(
              this.x + this.width / 2,
              this.y + this.height / 2,
              10,
              0,
              Math.PI * 2
            );
            ctx.fill();
          }

          const textX = this.x + this.width / 2;
          const textY = this.y + this.height / 2;
          const textContent = this.health > 0 ? this.health : "";

          ctx.font = `bold ${brickSize / 3}px 'Segoe UI', sans-serif`;
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";

          ctx.strokeStyle = 'rgba(0, 0, 0, 0.8)';
          ctx.lineWidth = brickSize / 14;
          ctx.lineJoin = 'round';
          ctx.strokeText(textContent, textX, textY);
          
          ctx.fillStyle = "white";
          ctx.fillText(textContent, textX, textY);
        }

        hit(damage = 1, powerUpSource = 'Normal') {
          if (this.isBeingDestroyed || this.health <= 0) {
            return;
          }

          const damageDealt = Math.min(this.health, damage);
          const sourceKey = powerUpSource.charAt(0).toUpperCase() + powerUpSource.slice(1);
          this.health -= damageDealt;
          powerUpDamageStats[sourceKey] = (powerUpDamageStats[sourceKey] || 0) + damageDealt;
          this.hitAnimation = 10;
          shakeScreen(4);

          if (playerPerk === "laserChance" && Math.random() < 0.1) {
            const rand = Math.random();
            if (rand < 0.4) {
              fireLaser(this.y + this.height / 2);
            } else if (rand < 0.8) {
              fireLaserVertical(this.x + this.width / 2);
            } else {
              fireLaserDiagonal(this.x + this.width / 2, this.y + this.height / 2, true);
              fireLaserDiagonal(this.x + this.width / 2, this.y + this.height / 2, false);
            }
          }

          if (this.health <= 0) {
            const hue = (this.initialHealth * 41) % 360;
            this.isBeingDestroyed = true;
            this.destructionTimer = 15;
            score += this.initialHealth;
            playSound("break", { isPowerUp: !!this.powerUp });
            createBackgroundRipple(this.x + this.width / 2, this.y + this.height / 2, 6);
            triggerBackgroundColorShift(hue);
            floatingTexts.push(new FloatingText(this.x + this.width / 2, this.y + this.height / 2, `+${this.initialHealth}`, '#FFD700', 22));
            
            createParticles(
              this.x + this.width / 2,
              this.y + this.height / 2,
              40,
              `hsl(${hue}, 100%, 70%)`
            );
            if (this.powerUp) {
              powerUps.push(new PowerUp(this.x + this.width / 2, this.y + this.height / 2, this.powerUp));
            }
          } else {
            playSound("bounce");
          }
        }
      }

      class PowerUp {
        constructor(x, y, type) {
          this.x = x;
          this.y = y;
          this.type = type;
          this.radius = 12;
          this.collected = false;
          this.yVel = 1;
        }

        draw() {
          ctx.save();
          ctx.translate(this.x, this.y);
          ctx.beginPath();
          ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
          ctx.fillStyle = "rgba(40,40,40,.8)";
          ctx.fill();
          ctx.strokeStyle = "white";
          ctx.lineWidth = 2;
          ctx.stroke();

          drawPowerUpSymbol(ctx, this.type, 0, 0, this.radius);

          ctx.restore();
        }

        update() {
          this.y += this.yVel * (isSpeedingUp ? SPEED_UP_MULTIPLIER : 1);
          if (this.y + this.radius > launchPosition.y) {
            this.collected = true;
          }
          return this.y < canvas.height;
        }
      }

      class FloatingText {
        constructor(x, y, text, color = "white", size = 20) {
          this.x = x;
          this.y = y;
          this.text = text;
          this.color = color;
          this.size = size;
          this.alpha = 1;
          this.vy = -1;
          this.duration = 60;
        }

        update() {
          this.y += this.vy;
          this.duration--;
          if (this.duration < 30) {
            this.alpha = this.duration / 30;
          }
        }

        draw() {
          ctx.save();
          ctx.globalAlpha = this.alpha;
          ctx.fillStyle = this.color;
          ctx.font = `bold ${this.size}px sans-serif`;
          ctx.textAlign = "center";
          ctx.fillText(this.text, this.x, this.y);
          ctx.restore();
        }
      }

      class Particle {
        constructor(x, y, color) {
          this.x = x;
          this.y = y;
          this.size = Math.random() * 5 + 2;
          this.vx = (Math.random() - 0.5) * 5;
          this.vy = (Math.random() - 0.5) * 5;
          this.alpha = 1;
          this.color = color;
        }
        update() {
          this.x += this.vx;
          this.y += this.vy;
          this.alpha -= 0.03;
        }
        draw() {
          ctx.globalAlpha = this.alpha;
          ctx.fillStyle = this.color;
          ctx.fillRect(this.x, this.y, this.size, this.size);
          ctx.globalAlpha = 1;
        }
      }

      function updateLaunchQueue() {
        currentLaunchQueue = [];
        let initialPowerUp = null;

        if (playerPerk === "fireStart") initialPowerUp = "fire";
        else if (playerPerk === "giantStart") initialPowerUp = "giant";
        else if (playerPerk === "scatterStart") initialPowerUp = "scatter";
        else if (playerPerk === "ghost") initialPowerUp = "ghost";
        else if (playerPerk === "multiplier") initialPowerUp = "multiplier";

        for (let i = 0; i < ballsToLaunch; i++) {
          const props = {
            powerUp: i === 0 && initialPowerUp ? initialPowerUp : null,
            isSplit: i === 0 && initialPowerUp === "multiplier",
            isGiant: i === 0 && initialPowerUp === "giant",
          };
          currentLaunchQueue.push(props);
        }
        powerUpQueue.forEach((type) => {
          currentLaunchQueue.push({
            powerUp: type,
            isSplit: type === "multiplier",
            isGiant: type === "giant",
          });
        });
      }

      function launchBalls() {
        ballsReturned = 0;
        totalBallsLaunchedThisRound = currentLaunchQueue.length;
        launchIndex = 0;
        launchTimer = 0;
      }

      function nextRound() {
        if (level >= levels.length) {
          gameState = "levelComplete";
          return;
        }

        bricks.forEach((brick) => {
          brick.y += brickSize;
        });

        if (
          bricks.some(
            (brick) => brick.y + brick.height >= launchPosition.y - 20
          )
        ) {
          gameState = "gameOver";
          playSound("gameOver");
          return;
        }

        const currentLevel = levels[level];
        if (rowsGeneratedThisLevel < currentLevel.rows) {
          const healthForThisRow =
            currentLevel.baseHealth +
            rowsGeneratedThisLevel * currentLevel.healthIncrease;
          const newHealth = generateRows(
            1,
            Math.max(BRICK_COLUMNS, healthForThisRow)
          );
          totalHealthGenerated += newHealth;
          rowsGeneratedThisLevel++;
        }
        powerUps = [];
        gameState = "aiming";
        updateLaunchQueue();
        launchIndex = 0;
        launchTimer = 0;
      }

      function checkCollisions() {
        for (let i = balls.length - 1; i >= 0; i--) {
          const ball = balls[i];
          let hasCollidedThisFrame = false;

          for (let j = bricks.length - 1; j >= 0; j--) {
            const brick = bricks[j];
            if (brick.isBeingDestroyed) continue;

            const closestX = Math.max(
              brick.x,
              Math.min(ball.x, brick.x + brick.width)
            );
            const closestY = Math.max(
              brick.y,
              Math.min(ball.y, brick.y + brick.height)
            );

            if (
              Math.hypot(ball.x - closestX, ball.y - closestY) < ball.radius
            ) {
              if (hasCollidedThisFrame) continue;
              hasCollidedThisFrame = true;

              createBackgroundRipple(ball.x, ball.y, 2.5);
              ball.timeSinceLastBrickHit = 0;
              if (ball.powerUp === "ghost" || ball.isGhosting) {
                continue;
              }

              if (closestX === ball.x) ball.vy *= -1;
              else if (closestY === ball.y) ball.vx *= -1;
              else {
                ball.vx *= -1;
                ball.vy *= -1;
              }
              ball.x += ball.vx * 0.1;
              ball.y += ball.vy * 0.1;

              if (ball.powerUp === "fire") {
                playSound("fireExplosion");
                createParticles(ball.x, ball.y, 30);
                for (let k = bricks.length - 1; k >= 0; k--) {
                  const nearBrick = bricks[k];
                  const dist = Math.hypot(
                    nearBrick.x + nearBrick.width / 2 - ball.x,
                    nearBrick.y + nearBrick.height / 2 - ball.y
                  );
                  if (dist < brickSize * 1.5) {
                    nearBrick.hit(ball.damage, 'Fire');
                  }
                }
              } else {
                brick.hit(ball.damage, ball.powerUp || 'Normal');
                if (ball.powerUp === "laser") {
                  fireLaser(brick.y + brick.height / 2);
                } else if (ball.powerUp === "multiplier" && ball.canSplit) {
                  ball.canSplit = false;
                  const angle = Math.atan2(ball.vy, ball.vx);
                  const splitDamage = Math.ceil(ball.damage / 2);
                  ball.damage = splitDamage;
                  ball.vx = Math.cos(angle + Math.PI / 8) * ball.speed;
                  ball.vy = Math.sin(angle + Math.PI / 8) * ball.speed;
                  const newBall = new Ball(
                    ball.x,
                    ball.y,
                    angle - Math.PI / 8,
                    false,
                    splitDamage
                  );
                  newBall.isSplitBall = true;
                  balls.push(newBall);
                  playSound("scatter");
                } else if (ball.powerUp === "scatter" && !ball.hasScattered) {
                  ball.hasScattered = true;
                  playSound("scatter");
                  createParticles(ball.x, ball.y, 20);
                  for (let s = 0; s < 3; s++) {
                    const scatterBall = new Ball(
                      ball.x,
                      ball.y,
                      Math.random() * Math.PI * 2,
                      true,
                      1
                    );
                    scatterBall.isSplitBall = true;
                    balls.push(scatterBall);
                  }
                }
              }
            }
          }
        }
      }

      function createLaserEffect(type, props) {
        visualEffects.push({
          type: type,
          alpha: 1,
          duration: 25,
          ...props,
        });
      }

      function fireLaser(y) {
        playSound("laser");
        shakeScreen(15);
        createParticles(canvas.width / 2, y, 100);
        createLaserEffect("laser_h", { y });

        for (let i = bricks.length - 1; i >= 0; i--) {
          const brick = bricks[i];
          if (Math.abs(y - (brick.y + brick.height / 2)) < brick.height / 2) {
            brick.hit(playerDamage, 'Laser');
          }
        }
      }

      function fireLaserVertical(x) {
        playSound("laser");
        shakeScreen(15);
        createParticles(x, canvas.height / 2, 100);
        createLaserEffect("laser_v", { x });

        for (let i = bricks.length - 1; i >= 0; i--) {
          const brick = bricks[i];
          if (Math.abs(x - (brick.x + brick.width / 2)) < brick.width / 2) {
            brick.hit(playerDamage, 'Laser');
          }
        }
      }

      function fireLaserDiagonal(x, y, isForward) {
        playSound("laser");
        shakeScreen(10);
        createLaserEffect("laser_d", { x, y, isForward });

        for (let i = bricks.length - 1; i >= 0; i--) {
          const brick = bricks[i];
          const brickCenterX = brick.x + brick.width / 2;
          const brickCenterY = brick.y + brick.height / 2;
          const lineDist = isForward
            ? Math.abs(brickCenterX - x - (brickCenterY - y))
            : Math.abs(brickCenterX - x + (brickCenterY - y));

          if (lineDist < (brick.width + brick.height) / 2) {
            createParticles(brickCenterX, brickCenterY, 15);
            brick.hit(playerDamage, 'Laser');
          }
        }
      }

      function generateRows(rowCount, totalHealth) {
        let newBricks = [];
        let availablePositions = [];
        for (let r = 0; r < rowCount; r++) {
          for (let c = 0; c < BRICK_COLUMNS; c++) {
            availablePositions.push({ r, c });
          }
        }

        const brickCount = Math.floor(
          availablePositions.length * (Math.random() * 0.2 + 0.5)
        );
        let healthToDistribute = totalHealth;

        const powerUpProbabilities = [
          { type: "fire", prob: 0.18 },
          { type: "giant", prob: 0.36 },
          { type: "extraBall", prob: 0.54 },
          { type: "laser", prob: 0.64 },
          { type: "scatter", prob: 0.74 },
          { type: "ghost", prob: 0.84 },
          { type: "multiplier", prob: 0.94 },
          { type: "damageUp", prob: 1.0 },
        ];

        for (let i = 0; i < brickCount; i++) {
          const randIndex = Math.floor(
            Math.random() * availablePositions.length
          );
          const pos = availablePositions.splice(randIndex, 1)[0];

          let powerUpType = null;
          if (Math.random() < 0.15) {
            const rand = Math.random();
            for (const p of powerUpProbabilities) {
              if (rand < p.prob) {
                powerUpType = p.type;
                break;
              }
            }
          }

          const newBrick = new Brick(
            pos.c * brickSize + 2,
            pos.r * brickSize + 2,
            1,
            powerUpType
          );
          newBricks.push(newBrick);
          healthToDistribute--;
        }

        while (healthToDistribute > 0) {
          const randomBrick =
            newBricks[Math.floor(Math.random() * newBricks.length)];
          randomBrick.health++;
          randomBrick.initialHealth++;
          healthToDistribute--;
        }

        if (newBricks.length > 0 && !newBricks.some((b) => b.powerUp)) {
          const randomBrick =
            newBricks[Math.floor(Math.random() * newBricks.length)];
          const allPowerUps = powerUpProbabilities.map((p) => p.type);
          randomBrick.powerUp =
            allPowerUps[Math.floor(Math.random() * allPowerUps.length)];
        }

        if (
          (playerPerk === "ghost" || playerPerk === "multiplier") &&
          newBricks.length > 0
        ) {
          newBricks[Math.floor(Math.random() * newBricks.length)].powerUp =
            playerPerk;
        }

        bricks.push(...newBricks);
        return totalHealth;
      }

      function setupLevel(levelIndex) {
        level = levelIndex;
        if (level >= levels.length) {
          gameState = "levelComplete";
          return;
        }

        ballsToLaunch = 1;
        powerUpQueue = [];
        launchIndex = 0;
        launchTimer = 0;
        ballsReturned = 0;
        totalBallsLaunchedThisRound = 0;

        const levelData = levels[level];
        score = 0;
        bricks = [];
        balls = [];
        powerUps = [];
        endScreenListenerAdded = false;
        powerUpDamageStats = {};
        gameState = "waiting";
        totalHealthGenerated = 0;
        rowsGeneratedThisLevel = 0;

        if (levelIndex === 0) {
          ballsToLaunch = playerPerk === "extraBallStart" ? 2 : 1;
          playerDamage = playerPerk === "damageUpStart" ? 2 : 1;
        }

        levelTargetScore =
          levelData.rows * levelData.baseHealth +
          (levelData.healthIncrease * levelData.rows * (levelData.rows - 1)) /
            2;

        const initialRowCount = 2;
        for (let i = 0; i < initialRowCount; i++) {
          const healthForThisRow =
            levelData.baseHealth +
            rowsGeneratedThisLevel * levelData.healthIncrease;
          const newHealth = generateRows(
            1,
            Math.max(BRICK_COLUMNS, healthForThisRow)
          );
          totalHealthGenerated += newHealth;
          rowsGeneratedThisLevel++;
        }

        updateLaunchQueue();
        gameState = "aiming";
      }

            function drawPredictedTrajectory() {
        const firstBallProps = currentLaunchQueue[0] || {};
        const simRadius = firstBallProps.isGiant ? ballRadius * 1.8 : ballRadius;

        const simBall = {
          x: launchPosition.x,
          y: launchPosition.y,
          vx: Math.cos(aimAngle) * (canvas.height / 160),
          vy: Math.sin(aimAngle) * (canvas.height / 160),
          radius: simRadius,
        };

        const simBricks = bricks.map(b => ({...b}));
        const totalRoundDamage = playerDamage * totalBallsLaunchedThisRound;
        let destroyedMarkers = [];

        ctx.beginPath();
        ctx.setLineDash([5, 10]);
        ctx.strokeStyle = "rgba(255, 255, 255, 0.5)";
        ctx.moveTo(simBall.x, simBall.y);

        const MAX_BOUNCES = 8;
        const MAX_STEPS = 1200;
        let bounces = 0;
        const isGhostPrediction = playerPerk === "ghost" || firstBallProps.powerUp === "ghost";

        for (let i = 0; i < MAX_STEPS && bounces < MAX_BOUNCES; i++) {
          simBall.x += simBall.vx;
          simBall.y += simBall.vy;

          let bouncedThisStep = false;

          if (simBall.x - simBall.radius <= 0 || simBall.x + simBall.radius >= canvas.width) {
            simBall.vx *= -1;
            simBall.x = simBall.x - simBall.radius <= 0 ? simBall.radius : canvas.width - simBall.radius;
            bouncedThisStep = true;
          }
          if (simBall.y - simBall.radius <= 0) {
            simBall.vy *= -1;
            simBall.y = simBall.radius;
            bouncedThisStep = true;
          }

          for (let j = simBricks.length - 1; j >= 0; j--) {
            const brick = simBricks[j];
            const closestX = Math.max(brick.x, Math.min(simBall.x, brick.x + brick.width));
            const closestY = Math.max(brick.y, Math.min(simBall.y, brick.y + brick.height));

            if (Math.hypot(simBall.x - closestX, simBall.y - closestY) < simBall.radius) {
              if (isGhostPrediction && bounces < 1) {
                continue; 
              }
              
              if (totalRoundDamage >= brick.health) {
                destroyedMarkers.push({ x: brick.x + brick.width / 2, y: brick.y + brick.height / 2 });
                simBricks.splice(j, 1);
                continue; 
              }

              if (closestX === simBall.x) simBall.vy *= -1;
              else if (closestY === simBall.y) simBall.vx *= -1;
              else {
                simBall.vx *= -1;
                simBall.vy *= -1;
              }
              bouncedThisStep = true;
              break; 
            }
          }

          ctx.lineTo(simBall.x, simBall.y);

          if (bouncedThisStep) {
            bounces++;
            if (bounces >= MAX_BOUNCES) {
              ctx.stroke(); 
              ctx.beginPath();
              ctx.arc(simBall.x, simBall.y, simBall.radius * 1.5, 0, Math.PI * 2);
              ctx.fillStyle = "rgba(255, 255, 255, 0.5)";
              ctx.fill();
              break;
            }
          }

          if (simBall.y > canvas.height) break;
        }

        ctx.stroke();
        ctx.setLineDash([]);
        
        destroyedMarkers.forEach(marker => {
            ctx.beginPath();
            ctx.strokeStyle = 'rgba(255, 80, 80, 0.8)';
            ctx.lineWidth = 3;
            ctx.moveTo(marker.x - 5, marker.y - 5);
            ctx.lineTo(marker.x + 5, marker.y + 5);
            ctx.moveTo(marker.x + 5, marker.y - 5);
            ctx.lineTo(marker.x - 5, marker.y + 5);
            ctx.stroke();
        });
      }

      function createParticles(x, y, count, color = null) {
        for (let i = 0; i < count; i++) {
          const particleColor =
            color || `hsl(${Math.random() * 360}, 100%, 70%)`;
          particles.push(new Particle(x, y, particleColor));
        }
      }

      function shakeScreen(intensity) {
        screenShake.intensity = intensity;
        screenShake.duration = 10;
      }

      function update() {
        if (gameState === "paused") return;

        if (gameState === "shooting") {
          if (launchIndex < totalBallsLaunchedThisRound) {
            launchTimer += 16.66;
            if (launchTimer >= LAUNCH_INTERVAL_MS) {
              launchTimer -= LAUNCH_INTERVAL_MS;
              const props = currentLaunchQueue[launchIndex];
              const newBall = new Ball(
                launchPosition.x,
                launchPosition.y,
                aimAngle
              );
              newBall.powerUp = props.powerUp;
              if (props.isSplit) newBall.canSplit = true;
              if (props.isGiant) newBall.radius = ballRadius * 1.8;
              balls.push(newBall);
              launchIndex++;
            }
          }

          for (
            let i = 0, speed = isSpeedingUp ? SPEED_UP_MULTIPLIER : 1;
            i < speed;
            i++
          ) {
            for (let j = balls.length - 1; j >= 0; j--) {
              if (!balls[j].update()) {
                if (!balls[j].isSplitBall) ballsReturned++;
                balls.splice(j, 1);
              }
            }

            powerUps.forEach((powerUp, index) => {
              powerUp.update();
              if (powerUp.collected) {
                handlePowerUpCollection(powerUp);
                powerUps.splice(index, 1);
              } else if (powerUp.y - powerUp.radius > canvas.height) {
                powerUps.splice(index, 1);
              }
            });

            checkCollisions();

            bricks.forEach(b => b.update());
            bricks = bricks.filter((b) => !b.isFullyDestroyed);

            if (
              balls.length === 0 &&
              powerUps.length === 0 &&
              ballsReturned >= totalBallsLaunchedThisRound
            ) {
              isSpeedingUp = false;
              isAiming = false;
              if (bricks.length === 0) {
                gameState = "levelComplete";
                playSound("levelUp");
                return;
              } else {
                gameState = "waiting";
                setTimeout(nextRound, 500);
              }
              break;
            }
          }
        }

        visualEffects.forEach((effect, index) => {
          effect.duration--;
          effect.alpha = effect.duration / 25;
          if (effect.duration <= 0) visualEffects.splice(index, 1);
        });

        particles.forEach((p, index) => {
          p.update();
          if (p.alpha <= 0) particles.splice(index, 1);
        });

        floatingTexts.forEach((ft, index) => {
          ft.update();
          if (ft.duration <= 0) floatingTexts.splice(index, 1);
        });

        if (screenShake.duration > 0) screenShake.duration--;
      }

      function handlePowerUpCollection(powerUp) {
        let text = "";
        let color = "white";
        switch (powerUp.type) {
          case "extraBall":
            ballsToLaunch++;
            text = "+1 Bola";
            color = "#32CD32";
            break;
          case "laser":
            powerUpQueue.push("laser");
            text = "Bola Laser!";
            color = "#FF00FF";
            break;
          case "fire":
            powerUpQueue.push("fire");
            text = "Bola de Fogo";
            color = "#FF4500";
            break;
          case "giant":
            powerUpQueue.push("giant");
            text = "Bola Gigante";
            color = "#1E90FF";
            break;
          case "scatter":
            powerUpQueue.push("scatter");
            text = "Chuva de Bolas";
            color = "#FFFF00";
            break;
          case "ghost":
            powerUpQueue.push("ghost");
            text = "Bola Fantasma";
            color = "#E6E6FA";
            break;
          case "multiplier":
            powerUpQueue.push("multiplier");
            text = "Multiplicador";
            color = "#800080";
            break;
          case "damageUp":
            playerDamage++;
            text = "+1 Dano";
            color = "#FF8C00";
            break;
        }
        floatingTexts.push(
          new FloatingText(powerUp.x, powerUp.y, text, color, canvas.width / 25)
        );
        if (powerUp.type !== "laser") playSound("powerup");
        updateLaunchQueue();
      }

      function draw() {
        const isGameActive =
          gameState !== "startScreen" &&
          gameState !== "gameOver" &&
          gameState !== "levelComplete" &&
          gameState !== "perkSelection";
          
        ctx.fillStyle = "#121212";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        if (!isGameActive || gameState === 'paused') {
            drawBackground();
        }

        ctx.save();

        if (
          isGameActive &&
          gameState !== "paused" &&
          screenShake.duration > 0
        ) {
          const shakeX = (Math.random() - 0.5) * screenShake.intensity;
          const shakeY = (Math.random() - 0.5) * screenShake.intensity;
          ctx.translate(shakeX, shakeY);
        }
        
        if (isGameActive) {
            drawBackground();
            drawGameElements();
        } else if (gameState === "startScreen") {
          drawStartScreen();
        } else if (gameState === "perkSelection") {
          drawPerkSelectionScreen();
        } else if (gameState === "gameOver" || gameState === "levelComplete") {
          drawEndScreen();
        }

        if (gameState === "paused") {
          drawPauseScreen();
        }

        ctx.restore();
        updateInfoPanel();
      }

      function drawGameElements() {
        if (gameState === "aiming" && isAiming) {
          drawPredictedTrajectory();
        }
        bricks.forEach((b) => b.draw());
        powerUps.forEach((p) => p.draw());
        balls.forEach((b) => b.draw());
        particles.forEach((p) => p.draw());
        floatingTexts.forEach((ft) => ft.draw());
        visualEffects.forEach(drawVisualEffect);
        if (
          gameState === "aiming" ||
          gameState === "shooting" ||
          gameState === "round_ending" ||
          gameState === "waiting"
        ) {
          drawLauncherQueue();
        }
      }

      function drawVisualEffect(effect) {
        const color = "#FF00FF";
        ctx.save();
        ctx.globalAlpha = Math.max(0, effect.alpha);
        ctx.shadowColor = color;

        if (effect.type === "laser_h") {
          ctx.shadowBlur = 20;
          ctx.fillStyle = color;
          ctx.fillRect(0, effect.y - 3, canvas.width, 6);
          ctx.shadowBlur = 10;
          ctx.fillStyle = "white";
          ctx.fillRect(0, effect.y - 1, canvas.width, 2);
        } else if (effect.type === "laser_v") {
          ctx.shadowBlur = 20;
          ctx.fillStyle = color;
          ctx.fillRect(effect.x - 3, 0, 6, canvas.height);
          ctx.shadowBlur = 10;
          ctx.fillStyle = "white";
          ctx.fillRect(effect.x - 1, 0, 2, canvas.height);
        } else if (effect.type === "laser_d") {
          ctx.translate(effect.x, effect.y);
          ctx.rotate(effect.isForward ? Math.PI / 4 : -Math.PI / 4);
          ctx.shadowBlur = 20;
          ctx.fillStyle = color;
          ctx.fillRect(canvas.width * -1.5, -3, canvas.width * 3, 6);
          ctx.shadowBlur = 10;
          ctx.fillStyle = "white";
          ctx.fillRect(canvas.width * -1.5, -1, canvas.width * 3, 2);
        }
        ctx.restore();
      }

            function drawLauncherQueue() {
        if (currentLaunchQueue.length === 0 || gameState === 'waiting') return;

        const animationProgress = gameState === "shooting" ? Math.min(1, launchTimer / LAUNCH_INTERVAL_MS) : 0;
        const queue = currentLaunchQueue.slice(launchIndex);

        if (queue.length === 0) return;
        
        const powerUpCounts = {};
        let hasNormalBall = false;
        
        queue.forEach(item => {
            if (item.powerUp) {
                powerUpCounts[item.powerUp] = (powerUpCounts[item.powerUp] || 0) + 1;
            } else {
                hasNormalBall = true;
            }
        });
        
        let displayQueue = Object.entries(powerUpCounts);
        if(hasNormalBall) {
            const normalBallCount = queue.filter(item => !item.powerUp).length;
            displayQueue.unshift(['normal', normalBallCount]);
        }

        const queueBallRadius = ballRadius * 1.1;
        const itemWidth = queueBallRadius * 2.2;
        const totalWidth = displayQueue.length * itemWidth;
        let startX = launchPosition.x - totalWidth / 2 + itemWidth / 2;
        
        if (gameState === 'shooting') {
            const firstType = queue[0].powerUp || 'normal';
            const countOfFirstType = powerUpCounts[firstType] || (firstType === 'normal' ? displayQueue.find(d => d[0] === 'normal')[1] : 0);
            
            if (countOfFirstType === 1) {
                 startX -= itemWidth * animationProgress / 2;
            }
        }
        
        let currentX = startX;

        displayQueue.forEach(([type, count]) => {
            ctx.save();
            ctx.translate(currentX, launchPosition.y);
            
            ctx.beginPath();
            ctx.arc(0, 0, queueBallRadius, 0, Math.PI * 2);
            ctx.fillStyle = "rgba(40,40,40,.8)";
            ctx.fill();
            ctx.strokeStyle = "white";
            ctx.lineWidth = 1.5;
            ctx.stroke();
            
            drawPowerUpSymbol(ctx, type, 0, 0, queueBallRadius);

            if (count > 0) {
                ctx.fillStyle = '#FFD700';
                ctx.font = `bold ${queueBallRadius * 0.9}px 'Segoe UI', sans-serif`;
                ctx.textAlign = 'right';
                ctx.textBaseline = 'bottom';
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 3;
                ctx.strokeText(`x${count}`, queueBallRadius, queueBallRadius);
                ctx.fillText(`x${count}`, queueBallRadius, queueBallRadius);
            }

            ctx.restore();
            currentX += itemWidth;
        });
      }

      function drawPowerUpSymbol(context, type, x, y, radius, animate = false) {
        const s = radius * 0.8;
        context.save();
        context.translate(x, y);
        context.lineWidth = radius / 6;
        context.lineJoin = 'round';
        context.lineCap = 'round';
        
        const time = Date.now();
        const animCycle = animate ? Math.sin(time / 800) : 0; 
        const normalizedAnimCycle = (animCycle + 1) / 2; 

        switch (type) {
          case "normal":
            context.strokeStyle = "#cccccc";
            context.beginPath();
            context.arc(0, 0, s*0.7, 0, Math.PI * 2);
            context.stroke();
            break;
          case "extraBall":
            context.strokeStyle = "#32CD32";
            context.beginPath();
            context.arc(0, 0, s*0.8, 0, Math.PI * 2);
            context.stroke();
            if (animate) {
                const colorPulse = Math.abs(animCycle);
                context.fillStyle = `rgb(${90 + 100 * colorPulse}, ${220 - 100 * colorPulse}, ${90 + 100 * colorPulse})`;
            } else {
                context.fillStyle = "#32CD32";
            }
            context.fillRect(-s*0.15, -s*0.5, s*0.3, s*1);
            context.fillRect(-s*0.5, -s*0.15, s*1, s*0.3);
            break;
          case "fire":
            if(animate) {
                context.save();
                const auraAlpha = 0.1 + normalizedAnimCycle * 0.3;
                context.globalAlpha = auraAlpha;
                context.fillStyle = "#FF9800";
                context.beginPath();
                context.moveTo(0, -s * 1.2);
                context.bezierCurveTo(s * 1.2, -s, s * 0.8, s * 0.3, s, s * 0.8);
                context.bezierCurveTo(s * 0.6, s * 1.2, -s * 0.6, s * 1.2, -s, s * 0.8);
                context.bezierCurveTo(-s * 0.8, s * 0.3, -s * 1.2, -s, 0, -s * 1.2);
                context.fill();
                context.restore();
            }
            context.fillStyle = "#FF4500";
            context.beginPath();
            context.moveTo(0, -s);
            context.bezierCurveTo(s, -s*0.8, s*0.6, s*0.1, s*0.8, s*0.6);
            context.bezierCurveTo(s*0.5, s, -s*0.5, s, -s*0.8, s*0.6);
            context.bezierCurveTo(-s*0.6, s*0.1, -s, -s*0.8, 0, -s);
            context.fill();
            break;
          case "giant":
            if(animate) {
                const scale = 1 + animCycle * 0.1;
                context.scale(scale, scale);
            }
            context.fillStyle = "#1E90FF";
            context.beginPath();
            context.arc(0, 0, s, 0, Math.PI * 2);
            context.fill();
            context.fillStyle = "rgba(255,255,255,0.5)";
            context.beginPath();
            context.arc(-s*0.3, -s*0.3, s*0.3, 0, Math.PI * 2);
            context.fill();
            break;
          case "laser":
          case "precisãolaser":
            context.strokeStyle = "#FF00FF";
            const animProgress = animate ? (time % 1200) / 1200 : 1;
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                const startRadius = s * 0.4;
                const endRadius = animate ? startRadius + (s * 0.6 * animProgress) : s;
                context.save();
                context.rotate(angle);
                context.beginPath();
                context.moveTo(0, -startRadius);
                context.lineTo(0, -endRadius);
                context.stroke();
                context.restore();
            }
            break;
          case "scatter":
            const numToShow = animate ? 1 + Math.floor(((time / 800) % 1) * 3) : 3;
            context.fillStyle = "#FFFF00";
            
            context.beginPath();
            context.arc(0, -s*0.3, s*0.5, 0, Math.PI*2);
            context.fill();

            if (numToShow >= 2) {
                context.beginPath();
                context.arc(-s*0.6, s*0.6, s*0.3, 0, Math.PI*2);
                context.fill();
            }
            if (numToShow >= 3) {
                context.beginPath();
                context.arc(s*0.6, s*0.6, s*0.3, 0, Math.PI*2);
                context.fill();
            }
            break;
          case "ghost":
            if (animate) {
                context.globalAlpha = 0.2 + normalizedAnimCycle * 0.8;
            }
            context.strokeStyle = "#E6E6FA";
            context.beginPath();
            context.arc(0, 0, s*0.8, 0, Math.PI, true);
            context.lineTo(-s*0.8, s*0.5);
            context.quadraticCurveTo(-s*0.4, s*0.2, 0, s*0.5);
            context.quadraticCurveTo(s*0.4, s*0.2, s*0.8, s*0.5);
            context.lineTo(s*0.8, 0);
            context.stroke();
            break;
          case "multiplier":
            context.strokeStyle = "#8A2BE2";
            const separation = animate ? normalizedAnimCycle * s * 0.3 : s * 0.3;
            context.beginPath();
            context.arc(-separation, 0, s*0.6, 0, Math.PI*2);
            context.stroke();
            
            if (animate) {
              const secondAlpha = Math.max(0, (normalizedAnimCycle - 0.5) * 2);
              context.globalAlpha = secondAlpha;
            }
            context.beginPath();
            context.arc(separation, 0, s*0.6, 0, Math.PI*2);
            context.stroke();
            break;
          case "damageUp":
            context.strokeStyle = "#FF8C00";
            if (animate) {
                const yOffset = animCycle * s * 0.2;
                context.translate(0, yOffset);
            }
            context.beginPath();
            context.moveTo(0, -s);
            context.lineTo(s*0.8, s*0.8);
            context.lineTo(-s*0.8, s*0.8);
            context.closePath();
            context.stroke();
            break;
        }
        context.restore();
      }

      function drawRoundRect(ctx, x, y, width, height, radius) {
        if (width < 2 * radius) radius = width / 2;
        if (height < 2 * radius) radius = height / 2;
        ctx.beginPath();
        ctx.moveTo(x + radius, y);
        ctx.arcTo(x + width, y, x + width, y + height, radius);
        ctx.arcTo(x + width, y + height, x, y + height, radius);
        ctx.arcTo(x, y + height, x, y, radius);
        ctx.arcTo(x, y, x + width, y, radius);
        ctx.closePath();
        return ctx;
      }

      function drawStartScreen() {
        ctx.filter = 'blur(8px)';
        ctx.drawImage(canvas, 0, 0);
        ctx.filter = 'none';

        const titleText = gameState === 'startScreen' ? "Escolha uma bola Inicial" : "Escolha uma Melhoria";
        ctx.fillStyle = "rgba(255, 255, 255, 0.9)";
        ctx.font = `bold ${canvas.width / 13}px 'Segoe UI', sans-serif`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.shadowColor = "black";
        ctx.shadowBlur = 8;
        ctx.fillText(
          titleText,
          canvas.width / 2,
          canvas.height / 5
        );
        ctx.shadowBlur = 0;

        powerUpChoices.forEach((choice) => {
          const isHovered =
            mouse.x > choice.x &&
            mouse.x < choice.x + choice.width &&
            mouse.y > choice.y &&
            mouse.y < choice.y + choice.height;

          ctx.save();
          if (isHovered) {
            ctx.shadowColor = choice.color;
            ctx.shadowBlur = 30;
            ctx.translate(choice.x + choice.width / 2, choice.y + choice.height / 2);
            ctx.scale(1.05, 1.05);
            ctx.translate(-(choice.x + choice.width / 2), -(choice.y + choice.height / 2));
          }

          ctx.fillStyle = "rgba(30, 30, 45, 0.65)";
          drawRoundRect(ctx, choice.x, choice.y, choice.width, choice.height, 15).fill();
          
          ctx.strokeStyle = "rgba(255, 255, 255, 0.2)";
          ctx.lineWidth = 1;
          drawRoundRect(ctx, choice.x, choice.y, choice.width, choice.height, 15).stroke();
          
          ctx.save();
          drawRoundRect(ctx, choice.x, choice.y, choice.width, choice.height, 15).clip();
          ctx.fillStyle = choice.color;
          ctx.fillRect(choice.x, choice.y, choice.width, 8);
          ctx.restore();

          ctx.shadowColor = "transparent";

          const iconRadius = choice.width / 5;
          drawPowerUpSymbol(ctx, choice.icon, choice.x + choice.width / 2, choice.y + choice.height * 0.3, iconRadius, true);

          ctx.fillStyle = "white";
          ctx.font = `bold ${canvas.width / 30}px 'Segoe UI', sans-serif`;
          const titleLines = choice.title.split("\n");
          const titleLineHeight = canvas.width / 28;
          let titleYStart = choice.y + choice.height * 0.58;
          if (titleLines.length > 1) {
            titleYStart -= titleLineHeight / 2;
          }
          titleLines.forEach((line, index) => {
            ctx.fillText(line, choice.x + choice.width / 2, titleYStart + index * titleLineHeight);
          });

          ctx.fillStyle = "#ccc";
          ctx.font = `${canvas.width / 42}px 'Segoe UI', sans-serif`;
          const descriptionLines = choice.description.split("\n");
          const descLineHeight = canvas.width / 40;
          let descYStart = choice.y + choice.height * 0.78;
          if (titleLines.length > 1) {
            descYStart += titleLineHeight / 2.5;
          }
          descriptionLines.forEach((line, index) => {
            ctx.fillText(line, choice.x + choice.width / 2, descYStart + index * descLineHeight);
          });

          ctx.restore();
        });
      }

      function drawEndScreen() {
        ctx.filter = 'blur(8px)';
        ctx.drawImage(canvas, 0, 0, canvas.width, canvas.height, 0, 0, canvas.width, canvas.height);
        ctx.filter = 'none';
        
        const isWin = gameState === "levelComplete";
        const isFinalWin = isWin && level >= levels.length - 1;
        const sortedStats = Object.entries(powerUpDamageStats).sort(([,a],[,b]) => b-a);
        const showStats = isWin && sortedStats.length > 0;
        
        let panelHeight = canvas.height * (showStats ? 0.8 : 0.5);
        if (isFinalWin) panelHeight = canvas.height * 0.5;

        uiButtons = [];
        const panelWidth = canvas.width * 0.85;
        const panelX = (canvas.width - panelWidth) / 2;
        const panelY = (canvas.height - panelHeight) / 2;
        
        ctx.fillStyle = "rgba(30, 30, 45, 0.7)";
        drawRoundRect(ctx, panelX, panelY, panelWidth, panelHeight, 20).fill();
        ctx.strokeStyle = isWin ? "rgba(0, 255, 127, 0.3)" : "rgba(255, 69, 0, 0.3)";
        ctx.lineWidth = 2;
        drawRoundRect(ctx, panelX, panelY, panelWidth, panelHeight, 20).stroke();

        let titleText = isFinalWin ? "VOCÊ VENCEU!" : isWin ? "VITÓRIA!" : "GAME OVER";
        ctx.fillStyle = isWin ? "#00FF7F" : "#FF4500";
        ctx.font = `bold ${canvas.width / 12}px 'Segoe UI', sans-serif`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.shadowColor = "black";
        ctx.shadowBlur = 5;
        ctx.fillText(titleText, canvas.width / 2, panelY + panelHeight * 0.15);
        ctx.shadowBlur = 0;

        const buttonHeight = panelHeight * 0.15 > 60 ? 60 : panelHeight * 0.15;
        let statsStartY = panelY + panelHeight * 0.3;
        let statsEndY = panelY + panelHeight - buttonHeight - panelHeight * 0.15;
        let currentY = statsStartY;
        
        if (isFinalWin) {
            ctx.fillStyle = "white";
            ctx.font = `bold ${canvas.width / 22}px 'Segoe UI', sans-serif`;
            ctx.fillText("Parabéns!", canvas.width / 2, panelY + panelHeight * 0.45);
        } else {
             ctx.fillStyle = "white";
             ctx.font = `bold ${canvas.width / 24}px 'Segoe UI', sans-serif`;
             ctx.fillText(`Pontuação: ${score}`, canvas.width / 2, currentY);
             currentY += canvas.height * 0.08;
             statsStartY = currentY;
        }

        if (showStats && !isFinalWin) {
            ctx.font = `bold ${canvas.width / 26}px 'Segoe UI', sans-serif`;
            ctx.fillStyle = "#ccc";
            ctx.fillText("Relatório de Dano:", canvas.width / 2, currentY);
            currentY += canvas.height * 0.05;
            statsStartY = currentY;
            
            const availableHeight = statsEndY - statsStartY;
            const lineHeight = Math.min(availableHeight / sortedStats.length, canvas.height * 0.05);

            sortedStats.forEach(([source, damage], index) => {
                if (source === 'Normal' && damage === 0) return;
                const itemY = statsStartY + (index * lineHeight);
                const iconName = Object.keys(powerUpDisplayNames).find(key => powerUpDisplayNames[key] === source)?.toLowerCase() || source.toLowerCase();
                const displayName = powerUpDisplayNames[source] || source;
                
                drawPowerUpSymbol(ctx, iconName, panelX + panelWidth * 0.12, itemY, canvas.width / 40, true);
                
                ctx.textAlign = 'left';
                ctx.fillStyle = '#ddd';
                ctx.font = `normal ${canvas.width / 32}px 'Segoe UI', sans-serif`;
                ctx.fillText(displayName, panelX + panelWidth * 0.22, itemY);
                
                ctx.textAlign = 'right';
                ctx.fillStyle = '#FFD700';
                ctx.font = `bold ${canvas.width / 32}px 'Segoe UI', sans-serif`;
                ctx.fillText(damage, panelX + panelWidth * 0.88, itemY);
            });
        }

        const buttonWidth = panelWidth * 0.7;
        const buttonX = panelX + (panelWidth - buttonWidth) / 2;
        let buttonY = panelY + panelHeight - buttonHeight - panelHeight * 0.08;
        
        let buttonConfig = {};
        if (isFinalWin) {
            buttonConfig = { text: "Reiniciar", onClick: () => { window.location.reload(); } };
        } else if (isWin) {
            buttonConfig = { text: "Escolher Melhoria", onClick: () => { setupPerkSelectionScreen(level + 1); } };
        } else {
            buttonConfig = { text: "Tentar Novamente", onClick: () => { window.location.reload(); } };
        }
        
        uiButtons.push({ x: buttonX, y: buttonY, width: buttonWidth, height: buttonHeight, ...buttonConfig });

        uiButtons.forEach((button) => {
          const isHovered = mouse.x > button.x && mouse.x < button.x + button.width && mouse.y > button.y && mouse.y < button.y + button.height;
          
          ctx.fillStyle = 'rgba(80, 80, 90, 0.7)';
          drawRoundRect(ctx, button.x, button.y, button.width, button.height, 10).fill();
          
          if (isHovered) {
              const sheenX = button.x + (mouse.x - button.x);
              const sheenY = button.y + (mouse.y - button.y);
              const sheenGrad = ctx.createRadialGradient(sheenX, sheenY, 0, sheenX, sheenY, button.width * 0.7);
              sheenGrad.addColorStop(0, 'rgba(255, 255, 255, 0.2)');
              sheenGrad.addColorStop(1, 'rgba(255, 255, 255, 0)');
              ctx.fillStyle = sheenGrad;

              ctx.save();
              drawRoundRect(ctx, button.x, button.y, button.width, button.height, 10).clip();
              ctx.fillRect(button.x, button.y, button.width, button.height);
              ctx.restore();
          }
          
          ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
          ctx.lineWidth = 1;
          drawRoundRect(ctx, button.x, button.y, button.width, button.height, 10).stroke();
          
          ctx.fillStyle = "white";
          ctx.font = `bold ${canvas.width / 25}px 'Segoe UI', sans-serif`;
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.shadowColor = "black";
          ctx.shadowBlur = 3;
          ctx.fillText(button.text, button.x + button.width / 2, button.y + button.height / 2);
          ctx.shadowBlur = 0;
        });
      }

      function drawPauseScreen() {
        ctx.filter = 'blur(8px)';
        ctx.drawImage(canvas, 0, 0);
        ctx.filter = 'none';

        uiButtons = [];
        const panelWidth = canvas.width * 0.8;
        const panelHeight = canvas.height * 0.4;
        const panelX = (canvas.width - panelWidth) / 2;
        const panelY = (canvas.height - panelHeight) / 2;

        ctx.fillStyle = "rgba(30, 30, 45, 0.7)";
        drawRoundRect(ctx, panelX, panelY, panelWidth, panelHeight, 20).fill();
        ctx.strokeStyle = "rgba(255, 255, 255, 0.2)";
        ctx.lineWidth = 1;
        drawRoundRect(ctx, panelX, panelY, panelWidth, panelHeight, 20).stroke();

        ctx.fillStyle = "white";
        ctx.font = `bold ${canvas.width / 12}px 'Segoe UI', sans-serif`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.shadowColor = "black";
        ctx.shadowBlur = 5;
        ctx.fillText("PAUSADO", canvas.width / 2, panelY + panelHeight * 0.35);
        ctx.shadowBlur = 0;

        const buttonWidth = panelWidth * 0.4;
        const buttonHeight = panelHeight * 0.2;
        const buttonY = panelY + panelHeight * 0.65;
        const gap = panelWidth * 0.05;
        const resumeButtonX = panelX + panelWidth / 2 - buttonWidth - gap / 2;
        const restartButtonX = panelX + panelWidth / 2 + gap / 2;

        uiButtons.push({ x: resumeButtonX, y: buttonY, width: buttonWidth, height: buttonHeight, text: "Continuar", onClick: unpauseGame });
        uiButtons.push({ x: restartButtonX, y: buttonY, width: buttonWidth, height: buttonHeight, text: "Reiniciar", onClick: () => { window.location.reload(); } });

        uiButtons.forEach((button) => {
          const isHovered = mouse.x > button.x && mouse.x < button.x + button.width && mouse.y > button.y && mouse.y < button.y + button.height;
          
          const btnGrad = ctx.createLinearGradient(button.x, button.y, button.x, button.y + button.height);
          if(isHovered) {
              btnGrad.addColorStop(0, 'rgba(120, 120, 120, 0.8)');
              btnGrad.addColorStop(1, 'rgba(100, 100, 100, 0.8)');
              ctx.shadowColor = "white";
              ctx.shadowBlur = 15;
          } else {
              btnGrad.addColorStop(0, 'rgba(80, 80, 90, 0.7)');
              btnGrad.addColorStop(1, 'rgba(60, 60, 70, 0.7)');
              ctx.shadowColor = "black";
              ctx.shadowBlur = 10;
          }
          ctx.fillStyle = btnGrad;
          
          drawRoundRect(ctx, button.x, button.y, button.width, button.height, 10).fill();
          ctx.shadowBlur = 0;
          
          ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
          ctx.lineWidth = 1;
          drawRoundRect(ctx, button.x, button.y, button.width, button.height, 10).stroke();
          
          ctx.fillStyle = "white";
          ctx.font = `bold ${canvas.width / 28}px 'Segoe UI', sans-serif`;
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillText(button.text, button.x + button.width / 2, button.y + button.height / 2);
        });
      }

      function updateInfoPanel() {
        if (gameState === "startScreen" || gameState === "perkSelection") {
            infoDiv.innerHTML = "";
            return;
        }

        const remainingBalls = gameState === 'aiming' ? currentLaunchQueue.length : totalBallsLaunchedThisRound - launchIndex;
        const progress = levelTargetScore > 0 ? Math.min(score / levelTargetScore, 1) : 0;
        const progressPercent = Math.floor(progress * 100);
        const progressColor = `hsl(${progress * 120}, 100%, 50%)`;
        
        infoDiv.innerHTML = `Nível: ${level + 1} | Bolas: ${remainingBalls} | Dano: ${playerDamage}<br>Progresso: <span style="color:${progressColor}">${progressPercent}%</span>`;
      }

      function gameLoop() {
        update();
        if (gameState !== 'paused') {
            updateBackground();
        }
        draw();
        requestAnimationFrame(gameLoop);
      }

      let perkChoices = [];
      let nextLevelAfterPerk = 0;

      function getPerkOptions() {
        return [
          {
            perk: "addBall",
            title: "Bola Extra",
            description: "Comece cada turno\ncom +1 bola.",
            icon: "extraBall",
            color: "#32CD32",
            apply: () => {
              ballsToLaunch++;
            },
          },
          {
            perk: "addDamage",
            title: "Dano Aumentado",
            description: "Aumenta o dano\nde todas as bolas\nem +1.",
            icon: "damageUp",
            color: "#FF8C00",
            apply: () => {
              playerDamage++;
            },
          },
          {
            perk: "laserChance",
            title: "Precisão Laser",
            description: "10% de chance de\nlaser ao atingir\num bloco.",
            icon: "laser",
            color: "#FF00FF",
            apply: () => {
              playerPerk = "laserChance";
            },
          },
          {
            perk: "fireStart",
            title: "Primeira Bola\nde Fogo",
            description: "Sua primeira bola\nsempre será\nde Fogo.",
            icon: "fire",
            color: "#FF4500",
            apply: () => {
              playerPerk = "fireStart";
            },
          },
          {
            perk: "giantStart",
            title: "Primeira Bola\nGigante",
            description: "Sua primeira bola\nsempre será\nGigante.",
            icon: "giant",
            color: "#1E90FF",
            apply: () => {
              playerPerk = "giantStart";
            },
          },
        ];
      }

      function setupPerkSelectionScreen(nextLevel) {
        gameState = "perkSelection";
        nextLevelAfterPerk = nextLevel;

        let allPerks = getPerkOptions();
        for (let i = allPerks.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [allPerks[i], allPerks[j]] = [allPerks[j], allPerks[i]];
        }
        const selectedPerks = allPerks.slice(0, 3);

        const cols = 3;
        const margin = canvas.width / 20;
        const cardWidth = (canvas.width - margin * (cols + 1)) / cols;
        const cardHeight = canvas.height / 2.8;

        perkChoices = selectedPerks.map((perk, index) => ({
          ...perk,
          x: margin + index * (cardWidth + margin),
          y: canvas.height / 2 - cardHeight / 2,
          width: cardWidth,
          height: cardHeight,
        }));

        powerUpChoices = perkChoices;
      }

      function drawPerkSelectionScreen() {
        drawStartScreen();
      }

      function handlePerkSelectionClick(event) {
        if (gameState !== "perkSelection") return;
        const rect = canvas.getBoundingClientRect();
        let clickX, clickY;
        if (event.changedTouches) {
            clickX = event.changedTouches[0].clientX - rect.left;
            clickY = event.changedTouches[0].clientY - rect.top;
        } else {
            clickX = event.clientX - rect.left;
            clickY = event.clientY - rect.top;
        }

        for (const choice of perkChoices) {
          if (
            clickX > choice.x &&
            clickX < choice.x + choice.width &&
            clickY > choice.y &&
            clickY < choice.y + choice.height
          ) {
            choice.apply();
            setupLevel(nextLevelAfterPerk);
            break;
          }
        }
      }

      function setupStartScreen() {
        resizeGame();
        gameState = "startScreen";
        let perks = [
          {
            perk: "laserChance",
            title: "Precisão\nLaser",
            description: "10% de chance de\nlaser ao atingir\num bloco.",
            icon: "laser",
            color: "#FF00FF",
          },
          {
            perk: "ghost",
            title: "Bola\nFantasma",
            description:
              "Comece com uma bola\nque atravessa os\nprimeiros blocos.",
            icon: "ghost",
            color: "#E6E6FA",
          },
          {
            perk: "multiplier",
            title: "Multiplicador",
            description:
              "Comece com uma bola\nque se divide em\nduas ao colidir.",
            icon: "multiplier",
            color: "#800080",
          },
          {
            perk: "fireStart",
            title: "Bola\nde Fogo",
            description:
              "Sua primeira bola\nexplode ao colidir,\nacertando em área.",
            icon: "fire",
            color: "#FF4500",
          },
          {
            perk: "giantStart",
            title: "Bola\nGigante",
            description:
              "Sua primeira bola\né maior e dá mais\ndano ao colidir.",
            icon: "giant",
            color: "#1E90FF",
          },
          {
            perk: "scatterStart",
            title: "Chuva\nde Bolas",
            description: "Sua primeira bola\nsolta 3 bolinhas\nao colidir.",
            icon: "scatter",
            color: "#FFFF00",
          },
        ];

        for (let i = perks.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [perks[i], perks[j]] = [perks[j], perks[i]];
        }
        const selectedPerks = perks.slice(0, 3);

        const cols = 3;
        const margin = canvas.width / 20;
        const cardWidth = (canvas.width - margin * (cols + 1)) / cols;
        const cardHeight = canvas.height / 2.8;

        powerUpChoices = selectedPerks.map((perk, index) => {
          return {
            ...perk,
            x: margin + index * (cardWidth + margin),
            y: canvas.height / 2 - cardHeight / 2,
            width: cardWidth,
            height: cardHeight,
          };
        });

        const startScreenClickHandler = (event) => {
          if (gameState === "startScreen") {
            event.preventDefault();
            handleStartScreenClick(event, startScreenClickHandler);
          }
        };
        canvas.addEventListener("click", startScreenClickHandler);
        canvas.addEventListener("touchend", startScreenClickHandler);
      }

      function handleStartScreenClick(event, listener) {
        if (gameState !== "startScreen") return;
        const rect = canvas.getBoundingClientRect();
        let clickX, clickY;
        if (event.changedTouches) {
          clickX = event.changedTouches[0].clientX - rect.left;
          clickY = event.changedTouches[0].clientY - rect.top;
        } else {
          clickX = event.clientX - rect.left;
          clickY = event.clientY - rect.top;
        }

        for (const choice of powerUpChoices) {
          if (
            clickX > choice.x &&
            clickX < choice.x + choice.width &&
            clickY > choice.y &&
            clickY < choice.y + choice.height
          ) {
            playerPerk = choice.perk;
            canvas.removeEventListener("click", listener);
            canvas.removeEventListener("touchend", listener);
            setupLevel(0);
            break;
          }
        }
      }

      const unpauseGame = () => {
        if (gameState === "paused") {
          gameState = previousGameState;
        }
      };

      function handleMouseUp(event) {
        event.preventDefault();
        if (gameState === "perkSelection") {
          handlePerkSelectionClick(event);
          return;
        }
        
        const rect = canvas.getBoundingClientRect();
        let clickX, clickY;
        if (event.changedTouches) {
            clickX = event.changedTouches[0].clientX - rect.left;
            clickY = event.changedTouches[0].clientY - rect.top;
        } else {
            clickX = event.clientX - rect.left;
            clickY = event.clientY - rect.top;
        }

        const activeStates = ["paused", "gameOver", "levelComplete"];
        if (activeStates.includes(gameState)) {
          for (const button of uiButtons) {
            if (
              clickX > button.x &&
              clickX < button.x + button.width &&
              clickY > button.y &&
              clickY < button.y + button.height
            ) {
              button.onClick();
              return;
            }
          }
        }

        if (isAiming && gameState === "aiming") {
          isAiming = false;
          gameState = "shooting";
          launchBalls();
          playSound("launch");
        }
        isSpeedingUp = false;
      }

      function handleMouseDown(event) {
        event.preventDefault();
        if (gameState === "aiming") {
          isAiming = true;
          const rect = canvas.getBoundingClientRect();
          const touch = event.touches ? event.touches[0] : event;
          mouse.x = touch.clientX - rect.left;
          mouse.y = touch.clientY - rect.top;
          const dx = mouse.x - launchPosition.x;
          const dy = mouse.y - launchPosition.y;
          aimAngle = Math.atan2(dy, dx);
          if (aimAngle > -0.6) aimAngle = -0.6;
          if (aimAngle < -Math.PI + 0.6) aimAngle = -Math.PI + 0.6;
        } else if (gameState === "shooting" || gameState === "round_ending") {
          isSpeedingUp = true;
        }
      }

      function handleMouseMove(event) {
        event.preventDefault();
        const rect = canvas.getBoundingClientRect();
        const touch = event.touches ? event.touches[0] : event;
        mouse.x = touch.clientX - rect.left;
        mouse.y = touch.clientY - rect.top;

        if (isAiming) {
          const dx = mouse.x - launchPosition.x;
          const dy = mouse.y - launchPosition.y;
          aimAngle = Math.atan2(dy, dx);
          if (aimAngle > -0.6) aimAngle = -0.6;
          if (aimAngle < -Math.PI + 0.6) aimAngle = -Math.PI + 0.6;
        }
      }

      canvas.addEventListener("mousedown", handleMouseDown);
      canvas.addEventListener("mousemove", handleMouseMove);
      canvas.addEventListener("mouseup", handleMouseUp);
      canvas.addEventListener("touchstart", handleMouseDown);
      canvas.addEventListener("touchmove", handleMouseMove);
      canvas.addEventListener("touchend", handleMouseUp);

      window.addEventListener("blur", () => {
        if (
          gameState !== "paused" &&
          gameState !== "startScreen" &&
          gameState !== "gameOver" &&
          gameState !== "levelComplete"
        ) {
          previousGameState = gameState;
          gameState = "paused";
          isAiming = false;
        }
      });

      window.addEventListener("keydown", (event) => {
        if (event.key === "Escape") {
          if (gameState === "paused") {
            unpauseGame();
          } else if (gameState === "shooting" || gameState === "aiming") {
            previousGameState = gameState;
            gameState = "paused";
            isAiming = false;
          }
        }
      });

      window.addEventListener("resize", resizeGame);
      setupStartScreen();
      setupBackground();
      gameLoop();
    </script>
  </body>
</html>
