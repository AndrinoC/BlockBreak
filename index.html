<!DOCTYPE html>
<html lang="pt-br">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>BlockBreaker</title>
    <style>
      body {
        background-color: #121212;
        color: #ffffff;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        height: 100vh;
        margin: 0;
        font-family: "Consolas", "Courier New", monospace;
        overflow: hidden;
      }

      canvas {
        background-color: #282828;
        border-radius: 8px;
        box-shadow: 0 0 20px rgba(255, 255, 255, 0.1);
        max-width: 100%;
        max-height: 100%;
      }

      #info {
        margin-top: 15px;
        font-size: 1.2em;
        color: #ccc;
      }
    </style>
  </head>

  <body>
    <canvas id="gameCanvas"></canvas>
    <div id="info">Clique e arraste para mirar. Solte para lançar.</div>
    <script>
      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");
      const infoDiv = document.getElementById("info");
      const aspectRatio = 9 / 16;
      let canvasHeight, canvasWidth;

      const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

      const BRICK_COLUMNS = 8;
      const SPEED_UP_MULTIPLIER = 2;
      const LAUNCH_INTERVAL_MS = 150;
      const NORMAL_BALL_TRAIL_LENGTH = 10;
      const SMALL_BALL_TRAIL_LENGTH = 4;
      let ballRadius = 8;
      let brickSize = canvas.width / BRICK_COLUMNS;
      let balls = [];
      let bricks = [];
      let powerUps = [];
      let particles = [];
      let floatingTexts = [];
      let visualEffects = [];

      let gameState = "aiming";
      let ballsToLaunch = 1;
      let baseBallsToLaunch = 1;
      let ballsReturned = 0;
      let level = 0;
      let score = 0;
      let levelTargetScore = 0;
      let totalHealthGenerated = 0;
      let totalBallsLaunchedThisRound = 0;
      let rowsGeneratedThisLevel = 0;
      let aimAngle = -Math.PI / 2;
      let isAiming = false;
      let isSpeedingUp = false;
      let mouse = { x: 0, y: 0 };
      let playerPerk = null;
      let powerUpChoices = [];
      let basePlayerDamage = 1;
      let playerDamage = 1;
      let permanentPowerUps = [];
      let previousGameState = "";
      let powerUpQueue = [];
      let uiButtons = [];
      let endScreenListenerAdded = false;
      let launchIndex = 0;
      let launchTimer = 0;
      let currentLaunchQueue = [];
      let backgroundMetaballs = [];
      let offscreenCanvas = document.createElement("canvas");
      let offscreenCtx = offscreenCanvas.getContext("2d");
      let comboCount = 0;
      let comboTimer = 0;
      const COMBO_TIMEOUT = 2000;
      let transitionTimer = 0;
      const TRANSITION_DURATION = 3500;

      const levels = [
        { rows: 8, baseHealth: 15, healthIncrease: 3 },
        { rows: 12, baseHealth: 30, healthIncrease: 5 },
        { rows: 12, baseHealth: 60, healthIncrease: 10 },
        { rows: 15, baseHealth: 100, healthIncrease: 15 },
        { rows: 20, baseHealth: 150, healthIncrease: 25 },
        { rows: 22, baseHealth: 200, healthIncrease: 35 },
        { rows: 25, baseHealth: 280, healthIncrease: 45 },
        { rows: 25, baseHealth: 380, healthIncrease: 60 },
        { rows: 28, baseHealth: 500, healthIncrease: 80 },
        { rows: 30, baseHealth: 700, healthIncrease: 100 },
      ];

      const powerUpPoolsByLevel = {
        0: ["extraBall", "damageUp"],
        1: ["extraBall", "damageUp", "fire"],
        2: ["extraBall", "damageUp", "fire", "laser"],
        3: ["extraBall", "damageUp", "fire", "laser", "scatter"],
        4: ["extraBall", "damageUp", "fire", "laser", "scatter", "multiplier"],
        5: [
          "extraBall",
          "damageUp",
          "fire",
          "laser",
          "scatter",
          "multiplier",
          "giant",
        ],
        6: [
          "extraBall",
          "damageUp",
          "fire",
          "laser",
          "scatter",
          "multiplier",
          "giant",
          "ghost",
        ],
        7: [
          "extraBall",
          "damageUp",
          "fire",
          "laser",
          "scatter",
          "multiplier",
          "giant",
          "ghost",
          "debuff",
        ],
      };

      const powerUpDisplayNames = {
        Normal: "Normal",
        ExtraBall: "Bola Extra",
        Fire: "Bola de Fogo",
        Giant: "Bola Gigante",
        Scatter: "Chuva de Bolas",
        Laser: "Precisão Laser",
        Ghost: "Bola Fantasma",
        Multiplier: "Multiplicador",
        DamageUp: "Dano Aumentado",
        Debuff: "Enfraquecer",
      };

      const launchPosition = {
        x: canvas.width / 2,
        y: canvas.height - 30,
      };

      let screenShake = {
        intensity: 0,
        duration: 0,
      };

      function hslToRgb(h, s, l) {
        let r, g, b;
        if (s == 0) {
          r = g = b = l;
        } else {
          const hue2rgb = (p, q, t) => {
            if (t < 0) t += 1;
            if (t > 1) t -= 1;
            if (t < 1 / 6) return p + (q - p) * 6 * t;
            if (t < 1 / 2) return q;
            if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
            return p;
          };
          const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
          const p = 2 * l - q;
          r = hue2rgb(p, q, h + 1 / 3);
          g = hue2rgb(p, q, h);
          b = hue2rgb(p, q, h - 1 / 3);
        }
        return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
      }

      class Metaball {
        constructor() {
          this.x = Math.random() * canvas.width;
          this.y = Math.random() * canvas.height;
          this.vx = (Math.random() - 0.5) * 0.8;
          this.vy = (Math.random() - 0.5) * 0.8;
          this.radius = Math.random() * 80 + 70;
          this.radiusSq = this.radius * this.radius;
          this.wanderAngle = Math.random() * Math.PI * 2;
          this.hue = Math.random() * 360;
          this.targetHue = this.hue;
          this.colorChangeTimer = Math.random() * 5000;
          this.color = hslToRgb(this.hue / 360, 0.7, 0.3);
        }

        update() {
          this.colorChangeTimer -= 16.67;
          if (this.colorChangeTimer <= 0) {
            this.targetHue = Math.random() * 360;
            this.colorChangeTimer = 5000 + Math.random() * 5000;
          }

          let diff = this.targetHue - this.hue;
          if (Math.abs(diff) > 180) {
            if (diff > 0) diff -= 360;
            else diff += 360;
          }
          this.hue += diff * 0.005;
          this.hue = (this.hue + 360) % 360;
          this.color = hslToRgb(this.hue / 360, 0.6, 0.35);

          this.wanderAngle += (Math.random() - 0.5) * 0.25;
          const wanderForceX = Math.cos(this.wanderAngle) * 0.03;
          const wanderForceY = Math.sin(this.wanderAngle) * 0.03;
          this.vx += wanderForceX;
          this.vy += wanderForceY;

          const pullToCenterX = (canvas.width / 2 - this.x) * 0.00005;
          const pullToCenterY = (canvas.height / 2 - this.y) * 0.00005;
          this.vx += pullToCenterX;
          this.vy += pullToCenterY;

          const speed = Math.hypot(this.vx, this.vy);
          const maxSpeed = 0.5;
          if (speed > maxSpeed) {
            const scale = maxSpeed / speed;
            this.vx *= scale;
            this.vy *= scale;
          }

          this.x += this.vx;
          this.y += this.vy;

          const bounceDamping = -0.6;
          if (this.x - this.radius < 0) {
            this.x = this.radius;
            this.vx *= bounceDamping;
            this.wanderAngle = Math.PI - this.wanderAngle;
          }
          if (this.x + this.radius > canvas.width) {
            this.x = canvas.width - this.radius;
            this.vx *= bounceDamping;
            this.wanderAngle = Math.PI - this.wanderAngle;
          }
          if (this.y - this.radius < 0) {
            this.y = this.radius;
            this.vy *= bounceDamping;
            this.wanderAngle = -this.wanderAngle;
          }
          if (this.y + this.radius > canvas.height) {
            this.y = canvas.height - this.radius;
            this.vy *= bounceDamping;
            this.wanderAngle = -this.wanderAngle;
          }
        }
      }

      function setupBackground() {
        backgroundMetaballs = [];
        for (let i = 0; i < 3; i++) {
          backgroundMetaballs.push(new Metaball());
        }
        offscreenCanvas.width = Math.floor(canvas.width / 5);
        offscreenCanvas.height = Math.floor(canvas.height / 5);
        offscreenCtx = offscreenCanvas.getContext("2d", {
          willReadFrequently: true,
        });
      }

      function updateBackground() {
        backgroundMetaballs.forEach((ball) => ball.update());
      }

      function drawBackground() {
        const width = offscreenCanvas.width;
        const height = offscreenCanvas.height;
        if (width === 0 || height === 0) return;

        const scaleX = canvas.width / width;
        const scaleY = canvas.height / height;
        const imageData = offscreenCtx.createImageData(width, height);
        const data = imageData.data;
        const threshold = 0.95;

        for (let i = 0; i < data.length; i += 4) {
          const x = (i / 4) % width;
          const y = Math.floor(i / 4 / width);
          const worldX = x * scaleX;
          const worldY = y * scaleY;

          let r = 0,
            g = 0,
            b = 0,
            totalWeight = 0;

          for (const ball of backgroundMetaballs) {
            const dx = worldX - ball.x;
            const dy = worldY - ball.y;
            const distSq = dx * dx + dy * dy;

            if (distSq === 0) continue;

            const weight = ball.radiusSq / distSq;
            r += ball.color[0] * weight;
            g += ball.color[1] * weight;
            b += ball.color[2] * weight;
            totalWeight += weight;
          }

          if (totalWeight >= threshold) {
            data[i] = r / totalWeight;
            data[i + 1] = g / totalWeight;
            data[i + 2] = b / totalWeight;
            data[i + 3] = 255;
          } else {
            data[i + 3] = 0;
          }
        }

        offscreenCtx.putImageData(imageData, 0, 0);
        ctx.globalAlpha = 0.6;
        ctx.imageSmoothingEnabled = true;
        ctx.drawImage(offscreenCanvas, 0, 0, canvas.width, canvas.height);
        ctx.globalAlpha = 1;
        ctx.imageSmoothingEnabled = false;
      }

      function createBackgroundRipple(x, y, intensity) {
        backgroundMetaballs.forEach((ball) => {
          const dx = ball.x - x;
          const dy = ball.y - y;
          const dist = Math.hypot(dx, dy);
          if (dist < 250) {
            const force = (1 - dist / 250) * intensity;
            ball.vx += (dx / dist) * force;
            ball.vy += (dy / dist) * force;
          }
        });
      }

      function resizeGame() {
        const windowHeight = window.innerHeight;
        const windowWidth = window.innerWidth;
        let newCanvasHeight = windowHeight * 0.9;
        let newCanvasWidth = newCanvasHeight * aspectRatio;

        if (newCanvasWidth > windowWidth * 0.95) {
          newCanvasWidth = windowWidth * 0.95;
          newCanvasHeight = newCanvasWidth / aspectRatio;
        }

        const oldCanvasWidth = canvas.width;
        const scaleRatio = newCanvasWidth / oldCanvasWidth;

        canvas.width = newCanvasWidth;
        canvas.height = newCanvasHeight;
        canvasWidth = newCanvasWidth;
        canvasHeight = newCanvasHeight;

        brickSize = canvas.width / BRICK_COLUMNS;
        ballRadius = canvas.height / 100;
        launchPosition.x = canvas.width / 2;
        launchPosition.y = canvas.height - 30;

        if (
          isNaN(scaleRatio) ||
          scaleRatio === Infinity ||
          gameState === "startScreen"
        ) {
          return;
        }

        bricks.forEach((brick) => {
          brick.x *= scaleRatio;
          brick.y *= scaleRatio;
          brick.width = brickSize - 4;
          brick.height = brickSize - 4;
        });

        balls.forEach((ball) => {
          ball.x *= scaleRatio;
          ball.y *= scaleRatio;
          ball.radius = ball.isSmall ? ballRadius * 0.6 : ballRadius;
        });

        powerUps.forEach((powerUp) => {
          powerUp.x *= scaleRatio;
          powerUp.y *= scaleRatio;
        });
      }

      const activeSoundCounts = {};
      const maxSounds = {
        bounce: 8,
        break: 6,
        default: 4,
      };

      function playSound(soundType, options = {}) {
        if (!audioCtx) return;

        const count = activeSoundCounts[soundType] || 0;
        const limit = maxSounds[soundType] || maxSounds.default;
        if (count >= limit) {
          return;
        }
        activeSoundCounts[soundType] = count + 1;

        const oscillator = audioCtx.createOscillator();
        const gainNode = audioCtx.createGain();
        oscillator.connect(gainNode);
        gainNode.connect(audioCtx.destination);
        gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);

        let duration = 0.5;

        switch (soundType) {
          case "ballDestroyed":
            oscillator.type = "noise";
            gainNode.gain.setValueAtTime(0.4, audioCtx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(
              0.001,
              audioCtx.currentTime + 0.2
            );
            duration = 0.2;
            break;
          case "bounce":
            oscillator.type = "sine";
            oscillator.frequency.setValueAtTime(440, audioCtx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(
              0.001,
              audioCtx.currentTime + 0.2
            );
            duration = 0.25;
            break;
          case "armorHit":
            oscillator.type = "square";
            oscillator.frequency.setValueAtTime(180, audioCtx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(
              0.001,
              audioCtx.currentTime + 0.15
            );
            duration = 0.2;
            break;
          case "break":
            oscillator.type = "sawtooth";
            oscillator.frequency.setValueAtTime(
              options.isPowerUp ? 880 : 660,
              audioCtx.currentTime
            );
            gainNode.gain.exponentialRampToValueAtTime(
              0.001,
              audioCtx.currentTime + 0.15
            );
            duration = 0.2;
            break;
          case "powerup":
            oscillator.type = "triangle";
            oscillator.frequency.setValueAtTime(523, audioCtx.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(
              1046,
              audioCtx.currentTime + 0.2
            );
            gainNode.gain.exponentialRampToValueAtTime(
              0.001,
              audioCtx.currentTime + 0.3
            );
            duration = 0.35;
            break;
          case "launch":
            oscillator.type = "square";
            oscillator.frequency.setValueAtTime(220, audioCtx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(
              0.001,
              audioCtx.currentTime + 0.3
            );
            duration = 0.3;
            break;
          case "gameOver":
            oscillator.type = "sawtooth";
            oscillator.frequency.setValueAtTime(200, audioCtx.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(
              50,
              audioCtx.currentTime + 1.5
            );
            gainNode.gain.exponentialRampToValueAtTime(
              0.001,
              audioCtx.currentTime + 1.5
            );
            duration = 1.5;
            break;
          case "laser":
            oscillator.type = "sawtooth";
            oscillator.frequency.setValueAtTime(1200, audioCtx.currentTime);
            oscillator.frequency.linearRampToValueAtTime(
              300,
              audioCtx.currentTime + 0.5
            );
            gainNode.gain.exponentialRampToValueAtTime(
              0.001,
              audioCtx.currentTime + 0.5
            );
            duration = 0.5;
            break;
          case "scatter":
            oscillator.type = "triangle";
            oscillator.frequency.setValueAtTime(600, audioCtx.currentTime);
            oscillator.frequency.linearRampToValueAtTime(
              1200,
              audioCtx.currentTime + 0.1
            );
            gainNode.gain.exponentialRampToValueAtTime(
              0.001,
              audioCtx.currentTime + 0.2
            );
            duration = 0.2;
            break;
          case "fireExplosion":
            oscillator.type = "square";
            oscillator.frequency.setValueAtTime(150, audioCtx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(
              0.001,
              audioCtx.currentTime + 0.4
            );
            duration = 0.4;
            break;
          case "levelUp":
            [523.25, 659.25, 783.99].forEach((freq, index) => {
              const osc = audioCtx.createOscillator();
              const gain = audioCtx.createGain();
              osc.connect(gain);
              gain.connect(audioCtx.destination);
              const startTime = audioCtx.currentTime + 0.1 * index;
              osc.frequency.setValueAtTime(freq, startTime);
              gain.gain.setValueAtTime(0.2, startTime);
              gain.gain.exponentialRampToValueAtTime(0.001, startTime + 0.4);
              osc.start(startTime);
              osc.stop(startTime + 0.5);
            });
            activeSoundCounts[soundType]--;
            return;
        }

        oscillator.onended = () => {
          if (activeSoundCounts[soundType]) {
            activeSoundCounts[soundType]--;
          }
        };

        oscillator.start(audioCtx.currentTime);
        oscillator.stop(audioCtx.currentTime + duration);
      }

      class Ball {
        constructor(x, y, angle, isSmall = false, damage = playerDamage) {
          this.x = x;
          this.y = y;
          this.speed = canvas.height / 50;
          this.vx = Math.cos(angle) * this.speed;
          this.vy = Math.sin(angle) * this.speed;
          this.isSmall = isSmall;
          this.radius = isSmall ? ballRadius * 0.6 : ballRadius;
          this.color = "#00BFFF";
          this.trail = [];
          this.powerUp = null;
          this.hasScattered = false;
          this.isGhosting = false;
          this.canSplit = false;
          this.isSplitBall = false;
          this.damage = damage;
          this.timeSinceLastBrickHit = 0;
          this.rippleTimer = 0;
        }

        draw() {
          this.trail.forEach((pos, index) => {
            const progress = index / this.trail.length;
            const opacity = progress * 0.6;

            if (this.powerUp === "fire") {
              const particleCount = 2;
              for (let i = 0; i < particleCount; i++) {
                ctx.beginPath();
                const particleSize =
                  this.radius * progress * (Math.random() * 0.4 + 0.6);
                const particleOpacity = opacity * (Math.random() * 0.5 + 0.5);
                const offsetX = (Math.random() - 0.5) * this.radius * 0.7;
                const offsetY = (Math.random() - 0.5) * this.radius * 0.7;
                const hue = 20 + Math.random() * 25;
                ctx.fillStyle = `hsla(${hue}, 100%, 60%, ${particleOpacity})`;
                ctx.arc(
                  pos.x + offsetX,
                  pos.y + offsetY,
                  particleSize,
                  0,
                  Math.PI * 2
                );
                ctx.fill();
              }
            } else {
              ctx.beginPath();
              let trailColor;
              if (this.powerUp === "giant")
                trailColor = `rgba(0,100,255,${opacity})`;
              else if (this.powerUp === "scatter")
                trailColor = `rgba(255,255,0,${opacity})`;
              else trailColor = `rgba(0,191,255,${opacity})`;
              ctx.fillStyle = trailColor;
              ctx.arc(pos.x, pos.y, this.radius * progress, 0, Math.PI * 2);
              ctx.fill();
            }
          });

          ctx.save();
          ctx.translate(this.x, this.y);
          const speedRatio = Math.min(
            1.5,
            Math.hypot(this.vx, this.vy) / (this.speed * 0.8)
          );
          const stretchFactor = 1 + (speedRatio - 1) * 0.2;
          const squashFactor = 1 / stretchFactor;
          const angle = Math.atan2(this.vy, this.vx);
          ctx.rotate(angle);
          ctx.scale(stretchFactor, squashFactor);

          ctx.beginPath();
          ctx.arc(0, 0, this.radius, 0, Math.PI * 2);

          if (this.powerUp === "fire") ctx.fillStyle = "#FF4500";
          else if (this.powerUp === "giant") ctx.fillStyle = "#1E90FF";
          else if (this.powerUp === "scatter") ctx.fillStyle = "#FFFF00";
          else ctx.fillStyle = this.color;

          ctx.fill();
          ctx.restore();
        }

        update(deltaFactor, deltaTime) {
          this.timeSinceLastBrickHit += deltaTime;
          this.rippleTimer += deltaTime;

          if (this.rippleTimer > 50) {
            createBackgroundRipple(this.x, this.y, 0.5);
            this.rippleTimer = 0;
          }

          this.trail.push({ x: this.x, y: this.y });
          const maxTrailLength = this.isSmall
            ? SMALL_BALL_TRAIL_LENGTH
            : NORMAL_BALL_TRAIL_LENGTH;
          if (this.trail.length > maxTrailLength) {
            this.trail.shift();
          }

          this.x += this.vx * deltaFactor;
          this.y += this.vy * deltaFactor;

          let bounced = false;
          if (
            this.x - this.radius <= 0 ||
            this.x + this.radius >= canvas.width
          ) {
            this.vx *= -1;
            this.x =
              this.x - this.radius <= 0
                ? this.radius
                : canvas.width - this.radius;
            bounced = true;

            const minVerticalRatio = 0.1;
            if (Math.abs(this.vy) < this.speed * minVerticalRatio) {
              this.vy =
                this.speed * minVerticalRatio * (Math.sign(this.vy) || 1);
              const newSpeed = Math.hypot(this.vx, this.vy);
              const scale = this.speed / newSpeed;
              this.vx *= scale;
              this.vy *= scale;
            }
          }

          if (this.y - this.radius <= 0) {
            this.vy *= -1;
            this.y = this.radius;
            bounced = true;
          }

          if (bounced) {
            if (this.powerUp === "ghost") this.powerUp = null;
            playSound("bounce");
            shakeScreen(2);
            createBackgroundRipple(this.x, this.y, 1);
          }

          return this.y <= canvas.height;
        }
      }

      class Brick {
        constructor(x, y, health, powerUpType = null, types = []) {
          this.x = x;
          this.y = y;
          this.width = brickSize - 4;
          this.height = brickSize - 4;
          this.health = health;
          this.initialHealth = health;
          this.powerUp = powerUpType;
          this.hitAnimation = 0;
          this.isBeingDestroyed = false;
          this.destructionTimer = 0;
          this.types = types.length > 0 ? types : ["normal"];
          this.isWeakened = false;
          this.armorLevel = 0;
          if (this.types.includes("double_armored")) {
            this.armorLevel = 2;
          } else if (this.types.includes("armored")) {
            this.armorLevel = 1;
          }
          this.volatilePulse = 0;
        }

        update(deltaTime) {
          if (this.destructionTimer > 0) {
            this.destructionTimer -= deltaTime;
            if (this.destructionTimer <= 0) {
              this.isFullyDestroyed = true;
            }
          }
          if (this.hitAnimation > 0) {
            this.hitAnimation -= deltaTime;
          }

          if (this.types.includes("volatile")) {
            this.volatilePulse = (this.volatilePulse + deltaTime / 1000) % 1;
          }
        }

        draw() {
          if (this.isBeingDestroyed) {
            const progress = Math.max(0, this.destructionTimer / 250);
            const scale = progress;
            const alpha = progress;

            ctx.save();
            ctx.translate(this.x + this.width / 2, this.y + this.height / 2);
            ctx.scale(scale, scale);
            ctx.globalAlpha = alpha;
            ctx.translate(
              -(this.x + this.width / 2),
              -(this.y + this.height / 2)
            );

            this.drawContent();

            ctx.restore();
            return;
          }

          ctx.save();
          if (this.hitAnimation > 0) {
            const scale =
              1 + Math.sin((1 - this.hitAnimation / 170) * Math.PI) * 0.1;
            ctx.translate(this.x + this.width / 2, this.y + this.height / 2);
            ctx.scale(scale, scale);
            ctx.translate(
              -(this.x + this.width / 2),
              -(this.y + this.height / 2)
            );
          }

          this.drawContent();

          if (this.hitAnimation > 0) {
            const flashAlpha = (this.hitAnimation / 170) * 0.5;
            ctx.fillStyle = `rgba(255, 255, 255, ${flashAlpha})`;
            ctx.fillRect(this.x, this.y, this.width, this.height);
          }
          ctx.restore();
        }

        drawContent() {
          const hue = (this.initialHealth * 41) % 360;
          let color = `hsl(${hue}, 80%, 50%)`;
          if (this.types.includes("regenerating")) color = `hsl(120, 60%, 45%)`;
          ctx.fillStyle = color;
          ctx.fillRect(this.x, this.y, this.width, this.height);

          if (this.types.includes("regenerating")) {
            const pulse = 0.7 + Math.sin(Date.now() / 300) * 0.3;
            ctx.save();
            ctx.translate(this.x + this.width / 2, this.y + this.height / 2);
            ctx.scale(pulse, pulse);
            ctx.fillStyle = `rgba(255, 255, 255, ${0.4 + pulse * 0.3})`;
            ctx.fillRect(
              -this.width * 0.1,
              -this.height * 0.3,
              this.width * 0.2,
              this.height * 0.6
            );
            ctx.fillRect(
              -this.width * 0.3,
              -this.height * 0.1,
              this.width * 0.6,
              this.height * 0.2
            );
            ctx.restore();
          }

          if (this.types.includes("volatile")) {
            const pulse = 0.5 + Math.sin(Date.now() / 150) * 0.5;
            ctx.strokeStyle = `rgba(255, 100, 0, ${pulse * 0.8})`;
            ctx.lineWidth = 2 + pulse * 3;
            ctx.strokeRect(
              this.x + ctx.lineWidth / 2,
              this.y + ctx.lineWidth / 2,
              this.width - ctx.lineWidth,
              this.height - ctx.lineWidth
            );
          }

          if (this.armorLevel > 0) {
            const grad = ctx.createLinearGradient(
              this.x,
              this.y,
              this.x + this.width,
              this.y + this.height
            );
            grad.addColorStop(0, "rgba(220, 220, 220, 0.6)");
            grad.addColorStop(0.5, "rgba(160, 160, 160, 0.7)");
            grad.addColorStop(1, "rgba(220, 220, 220, 0.6)");
            ctx.fillStyle = grad;
            ctx.fillRect(this.x, this.y, this.width, this.height);
            ctx.strokeStyle = "#444";
            ctx.lineWidth = 4;
            ctx.strokeRect(
              this.x + 2,
              this.y + 2,
              this.width - 4,
              this.height - 4
            );
          }
          if (this.armorLevel > 1) {
            ctx.strokeStyle = "#111";
            ctx.lineWidth = 2;
            ctx.strokeRect(
              this.x + 6,
              this.y + 6,
              this.width - 12,
              this.height - 12
            );
          }

          if (this.types.includes("spiky")) {
            ctx.fillStyle = "#4A235A";
            const spikeCount = 8;
            for (let i = 0; i < spikeCount; i++) {
              ctx.save();
              ctx.translate(this.x + this.width / 2, this.y + this.height / 2);
              ctx.rotate((i / spikeCount) * Math.PI * 2);
              ctx.beginPath();
              ctx.moveTo(0, -this.height * 0.4);
              ctx.lineTo(this.width * 0.15, -this.height * 0.55);
              ctx.lineTo(-this.width * 0.15, -this.height * 0.55);
              ctx.closePath();
              ctx.fill();
              ctx.restore();
            }
          }

          if (this.isWeakened) {
            ctx.strokeStyle = "#8A2BE2";
            ctx.lineWidth = 4;
            ctx.setLineDash([8, 4]);
            ctx.strokeRect(
              this.x + 2,
              this.y + 2,
              this.width - 4,
              this.height - 4
            );
            ctx.setLineDash([]);
          }

          if (this.powerUp) {
            const animatedHue = (Date.now() / 10) % 360;
            ctx.fillStyle = `hsl(${animatedHue}, 90%, 60%)`;
            ctx.beginPath();
            ctx.arc(
              this.x + this.width / 2,
              this.y + this.height / 2,
              10,
              0,
              Math.PI * 2
            );
            ctx.fill();
          }

          const textX = this.x + this.width / 2;
          const textY = this.y + this.height / 2;
          const textContent = this.health > 0 ? this.health : "";

          ctx.font = `bold ${brickSize / 3}px 'Segoe UI', sans-serif`;
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";

          ctx.strokeStyle = "rgba(0, 0, 0, 0.8)";
          ctx.lineWidth = brickSize / 14;
          ctx.lineJoin = "round";
          ctx.strokeText(textContent, textX, textY);

          ctx.fillStyle = "white";
          ctx.fillText(textContent, textX, textY);
        }

        applyDebuff() {
          if (!this.isWeakened) {
            this.isWeakened = true;
            playSound("powerup");
            floatingTexts.push(
              new FloatingText(
                this.x + this.width / 2,
                this.y,
                "Enfraquecido!",
                "#8A2BE2",
                18
              )
            );
          }
        }

        hit(damage = 1, powerUpSource = "Normal") {
          if (this.isBeingDestroyed || this.health <= 0) return;

          if (this.armorLevel > 0) {
            this.armorLevel--;
            this.hitAnimation = 170;
            playSound("armorHit");
            shakeScreen(6);
            createParticles(
              this.x + this.width / 2,
              this.y + this.height / 2,
              20,
              this.armorLevel === 1 ? "#888" : "#c0c0c0"
            );
            return;
          }

          let finalDamage = damage;
          if (this.isWeakened) {
            finalDamage *= 2;
            this.isWeakened = false;
            floatingTexts.push(
              new FloatingText(
                this.x + this.width / 2,
                this.y,
                `-${finalDamage}!`,
                "#FF4500",
                24
              )
            );
          }
          if (this.types.includes("regenerating")) {
            this.regenCooldown = 3000;
          }

          const damageDealt = Math.min(this.health, finalDamage);
          const sourceKey =
            powerUpSource.charAt(0).toUpperCase() + powerUpSource.slice(1);
          this.health -= damageDealt;
          powerUpDamageStats[sourceKey] =
            (powerUpDamageStats[sourceKey] || 0) + damageDealt;
          this.hitAnimation = 170;
          shakeScreen(4);

          if (playerPerk === "laserChance" && Math.random() < 0.1) {
            const rand = Math.random();
            if (rand < 0.4) {
              fireLaser(this.y + this.height / 2);
            } else if (rand < 0.8) {
              fireLaserVertical(this.x + this.width / 2);
            } else {
              fireLaserDiagonal(
                this.x + this.width / 2,
                this.y + this.height / 2,
                true
              );
              fireLaserDiagonal(
                this.x + this.width / 2,
                this.y + this.height / 2,
                false
              );
            }
          }

          if (this.health <= 0) {
            this.handleDestruction();
          } else {
            playSound("bounce");
          }
        }

        handleDestruction() {
          const hue = (this.initialHealth * 41) % 360;
          this.isBeingDestroyed = true;
          this.destructionTimer = 250;
          score += this.initialHealth;
          playSound("break", { isPowerUp: !!this.powerUp });
          createBackgroundRipple(
            this.x + this.width / 2,
            this.y + this.height / 2,
            6
          );
          floatingTexts.push(
            new FloatingText(
              this.x + this.width / 2,
              this.y + this.height / 2,
              `+${this.initialHealth}`,
              "#FFD700",
              22
            )
          );
          createParticles(
            this.x + this.width / 2,
            this.y + this.height / 2,
            40,
            `hsl(${hue}, 100%, 70%)`
          );
          if (this.powerUp) {
            powerUps.push(
              new PowerUp(
                this.x + this.width / 2,
                this.y + this.height / 2,
                this.powerUp
              )
            );
          }
          if (this.types.includes("volatile")) {
            playSound("fireExplosion");
            createParticles(
              this.x + this.width / 2,
              this.y + this.height / 2,
              80,
              "#FF4500"
            );
            shakeScreen(15);
            bricks.forEach((b) => {
              if (b !== this && !b.isBeingDestroyed) {
                const dist = Math.hypot(b.x - this.x, b.y - this.y);
                if (dist < brickSize * 2.5) {
                  if (b.types.includes("volatile")) {
                    b.handleDestruction();
                  } else {
                    b.hit(Math.ceil(this.initialHealth / 2), "Volatile");
                  }
                }
              }
            });
          }
        }
      }

      class PowerUp {
        constructor(x, y, type) {
          this.x = x;
          this.y = y;
          this.type = type;
          this.radius = 12;
          this.collected = false;
          this.yVel = 5;
        }

        draw() {
          ctx.save();
          ctx.translate(this.x, this.y);
          ctx.beginPath();
          ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
          ctx.fillStyle = "rgba(40,40,40,.8)";
          ctx.fill();
          ctx.strokeStyle = "white";
          ctx.lineWidth = 2;
          ctx.stroke();

          drawPowerUpSymbol(ctx, this.type, 0, 0, this.radius);

          ctx.restore();
        }

        update(deltaFactor) {
          this.y +=
            this.yVel * (isSpeedingUp ? SPEED_UP_MULTIPLIER : 1) * deltaFactor;
          if (this.y + this.radius > launchPosition.y) {
            this.collected = true;
          }
          return this.y < canvas.height;
        }
      }

      class FloatingText {
        constructor(x, y, text, color = "white", size = 20, duration = 1000) {
          this.x = x;
          this.y = y;
          this.text = text;
          this.color = color;
          this.size = size;
          this.alpha = 1;
          this.vy = -60;
          this.duration = duration;
        }

        update(deltaTime) {
          this.y += this.vy * (deltaTime / 1000);
          this.duration -= deltaTime;
          if (this.duration < 500) {
            this.alpha = this.duration / 500;
          }
        }

        draw() {
          ctx.save();
          ctx.globalAlpha = this.alpha;
          ctx.fillStyle = this.color;
          ctx.font = `bold ${this.size}px 'Segoe UI', sans-serif`;
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";

          ctx.shadowColor = "rgba(0, 0, 0, 0.8)";
          ctx.shadowBlur = 8;
          ctx.lineWidth = this.size / 10;
          ctx.strokeStyle = "rgba(0,0,0,0.5)";

          ctx.strokeText(this.text, this.x, this.y);
          ctx.fillText(this.text, this.x, this.y);
          ctx.restore();
        }
      }

      class Particle {
        constructor(x, y, color) {
          this.x = x;
          this.y = y;
          this.size = Math.random() * 5 + 2;
          this.vx = (Math.random() - 0.5) * 350;
          this.vy = (Math.random() - 0.8) * 350;
          this.alpha = 1;
          this.color = color;
          this.gravity = 400;
          this.drag = 0.98;
        }
        update(deltaTime) {
          const deltaSeconds = deltaTime / 1000;
          this.vy += this.gravity * deltaSeconds;
          this.vx *= this.drag;

          this.x += this.vx * deltaSeconds;
          this.y += this.vy * deltaSeconds;
          this.alpha -= deltaTime / 500;
        }
        draw() {
          ctx.globalAlpha = this.alpha;
          ctx.fillStyle = this.color;
          ctx.fillRect(this.x, this.y, this.size, this.size);
          ctx.globalAlpha = 1;
        }
      }

      function updateLaunchQueue() {
        currentLaunchQueue = [];

        permanentPowerUps.forEach((type) => {
          currentLaunchQueue.push({
            powerUp: type,
            isSplit: type === "multiplier",
            isGiant: type === "giant",
          });
        });

        for (let i = 0; i < ballsToLaunch; i++) {
          currentLaunchQueue.push({
            powerUp: null,
            isSplit: false,
            isGiant: false,
          });
        }

        powerUpQueue.forEach((type) => {
          currentLaunchQueue.push({
            powerUp: type,
            isSplit: type === "multiplier",
            isGiant: type === "giant",
          });
        });
      }

      function launchBalls() {
        ballsReturned = 0;
        totalBallsLaunchedThisRound = currentLaunchQueue.length;
        launchIndex = 0;
        launchTimer = 0;
      }

      function nextRound(screenCleared = false) {
        if (level >= levels.length) {
          gameState = "levelComplete";
          uiButtons = [];
          return;
        }

        bricks.forEach((brick) => {
          brick.y += brickSize;
          if (
            brick.types.includes("regenerating") &&
            brick.health < brick.initialHealth
          ) {
            brick.health++;
            floatingTexts.push(
              new FloatingText(
                brick.x + brick.width / 2,
                brick.y + brick.height / 2,
                "+1",
                "#2ECC71",
                20
              )
            );
          }
        });

        if (
          bricks.some(
            (brick) => brick.y + brick.height >= launchPosition.y - 20
          )
        ) {
          gameState = "gameOver";
          playSound("gameOver");
          return;
        }

        const currentLevel = levels[level];
        const rowsToSpawn = screenCleared ? 2 : 1;

        if (rowsGeneratedThisLevel < currentLevel.rows) {
          if (screenCleared) {
            floatingTexts.push(
              new FloatingText(
                canvas.width / 2,
                canvas.height * 0.3,
                "TELA LIMPA! +1 ONDA BÔNUS!",
                "#FFD700",
                canvas.width / 14,
                2000
              )
            );
          }

          for (
            let i = 0;
            i < rowsToSpawn && rowsGeneratedThisLevel < currentLevel.rows;
            i++
          ) {
            const healthForThisRow =
              currentLevel.baseHealth +
              rowsGeneratedThisLevel * currentLevel.healthIncrease;
            const newHealth = generateRows(
              1,
              Math.max(BRICK_COLUMNS, healthForThisRow)
            );
            totalHealthGenerated += newHealth;
            rowsGeneratedThisLevel++;
          }

          const wavesRemaining = currentLevel.rows - rowsGeneratedThisLevel;
          if (wavesRemaining >= 0) {
            let message = "";
            let messageSize = canvas.width / 18;

            if (wavesRemaining === 0) {
              message = "ONDA FINAL!";
              messageSize = canvas.width / 12;
            } else if (wavesRemaining === 1) {
              message = "A penúltima onda se aproxima!";
            } else {
              message = `${wavesRemaining} ondas restantes`;
            }

            floatingTexts.push(
              new FloatingText(
                canvas.width / 2,
                canvas.height * 0.15,
                message,
                "#FFFFFF",
                messageSize,
                1500
              )
            );
          }
        }

        powerUps = [];
        gameState = "aiming";
        updateLaunchQueue();
        launchIndex = 0;
        launchTimer = 0;
      }

      function checkCollisions() {
        for (let i = balls.length - 1; i >= 0; i--) {
          const ball = balls[i];
          let hasCollidedThisFrame = false;

          for (let j = bricks.length - 1; j >= 0; j--) {
            const brick = bricks[j];
            if (brick.isBeingDestroyed) continue;

            const closestX = Math.max(
              brick.x,
              Math.min(ball.x, brick.x + brick.width)
            );
            const closestY = Math.max(
              brick.y,
              Math.min(ball.y, brick.y + brick.height)
            );

            if (
              Math.hypot(ball.x - closestX, ball.y - closestY) < ball.radius
            ) {
              if (hasCollidedThisFrame) continue;
              hasCollidedThisFrame = true;

              createBackgroundRipple(ball.x, ball.y, 2.5);
              ball.timeSinceLastBrickHit = 0;

              if (ball.powerUp === "ghost" || ball.isGhosting) {
                continue;
              }
              if (ball.powerUp === "debuff") {
                brick.applyDebuff();
                ball.powerUp = null;
                continue;
              }

              if (closestX === ball.x) ball.vy *= -1;
              else if (closestY === ball.y) ball.vx *= -1;
              else {
                ball.vx *= -1;
                ball.vy *= -1;
              }
              ball.x += ball.vx * 0.1;
              ball.y += ball.vy * 0.1;

              if (ball.powerUp === "fire") {
                playSound("fireExplosion");
                createParticles(ball.x, ball.y, 30);
                for (let k = bricks.length - 1; k >= 0; k--) {
                  const nearBrick = bricks[k];
                  const dist = Math.hypot(
                    nearBrick.x + nearBrick.width / 2 - ball.x,
                    nearBrick.y + nearBrick.height / 2 - ball.y
                  );
                  if (dist < brickSize * 1.5) {
                    comboCount++;
                    comboTimer = COMBO_TIMEOUT;
                    nearBrick.hit(ball.damage, "Fire");
                  }
                }
              } else {
                comboCount++;
                comboTimer = COMBO_TIMEOUT;

                const brickHealthBeforeHit = brick.health;
                brick.hit(ball.damage, ball.powerUp || "Normal");

                if (
                  brickHealthBeforeHit > 0 &&
                  brick.health > 0 &&
                  brick.types.includes("spiky")
                ) {
                  playSound("ballDestroyed");
                  createParticles(ball.x, ball.y, 30, "#FF1493");
                  shakeScreen(5);
                  if (!ball.isSplitBall) {
                    ballsReturned++;
                  }
                  balls.splice(i, 1);
                  break;
                }

                if (ball.powerUp === "laser") {
                  fireLaser(brick.y + brick.height / 2);
                } else if (ball.powerUp === "multiplier" && ball.canSplit) {
                  ball.canSplit = false;
                  const angle = Math.atan2(ball.vy, ball.vx);
                  const splitDamage = Math.ceil(ball.damage / 2);
                  ball.damage = splitDamage;
                  ball.vx = Math.cos(angle + Math.PI / 8) * ball.speed;
                  ball.vy = Math.sin(angle + Math.PI / 8) * ball.speed;
                  const newBall = new Ball(
                    ball.x,
                    ball.y,
                    angle - Math.PI / 8,
                    false,
                    splitDamage
                  );
                  newBall.isSplitBall = true;
                  balls.push(newBall);
                  playSound("scatter");
                } else if (ball.powerUp === "scatter" && !ball.hasScattered) {
                  ball.hasScattered = true;
                  playSound("scatter");
                  createParticles(ball.x, ball.y, 20);
                  for (let s = 0; s < 3; s++) {
                    const scatterBall = new Ball(
                      ball.x,
                      ball.y,
                      Math.random() * Math.PI * 2,
                      true,
                      1
                    );
                    scatterBall.isSplitBall = true;
                    balls.push(scatterBall);
                  }
                }
              }
            }
          }
        }
      }

      function createLaserEffect(type, props) {
        visualEffects.push({
          type: type,
          alpha: 1,
          duration: 420,
          ...props,
        });
      }

      function fireLaser(y) {
        playSound("laser");
        shakeScreen(15);
        createLaserEffect("laser_h", { y });
        const laserDamage = Math.max(1, Math.ceil(playerDamage / 2));

        for (let i = bricks.length - 1; i >= 0; i--) {
          const brick = bricks[i];
          if (Math.abs(y - (brick.y + brick.height / 2)) < brick.height / 2) {
            comboCount++;
            comboTimer = COMBO_TIMEOUT;
            brick.hit(laserDamage, "Laser");
          }
        }
      }

      function fireLaserVertical(x) {
        playSound("laser");
        shakeScreen(15);
        createLaserEffect("laser_v", { x });
        const laserDamage = Math.max(1, Math.ceil(playerDamage / 2));

        for (let i = bricks.length - 1; i >= 0; i--) {
          const brick = bricks[i];
          if (Math.abs(x - (brick.x + brick.width / 2)) < brick.width / 2) {
            comboCount++;
            comboTimer = COMBO_TIMEOUT;
            brick.hit(laserDamage, "Laser");
          }
        }
      }

      function fireLaserDiagonal(x, y, isForward) {
        playSound("laser");
        shakeScreen(10);
        createLaserEffect("laser_d", { x, y, isForward });
        const laserDamage = Math.max(1, Math.ceil(playerDamage / 2));

        for (let i = bricks.length - 1; i >= 0; i--) {
          const brick = bricks[i];
          const brickCenterX = brick.x + brick.width / 2;
          const brickCenterY = brick.y + brick.height / 2;
          const lineDist = isForward
            ? Math.abs(brickCenterX - x - (brickCenterY - y))
            : Math.abs(brickCenterX - x + (brickCenterY - y));

          if (lineDist < (brick.width + brick.height) / 2) {
            comboCount++;
            comboTimer = COMBO_TIMEOUT;
            brick.hit(laserDamage, "Laser");
          }
        }
      }

      function generateRows(rowCount, totalHealth) {
        let newBricks = [];
        let availablePositions = [];
        for (let r = 0; r < rowCount; r++) {
          for (let c = 0; c < BRICK_COLUMNS; c++) {
            availablePositions.push({ r, c });
          }
        }

        const brickCount = Math.floor(
          availablePositions.length * (Math.random() * 0.2 + 0.5)
        );
        let healthToDistribute = totalHealth;
        const currentPowerUpPool = powerUpPoolsByLevel[Math.min(level, 7)];

        for (let i = 0; i < brickCount; i++) {
          const randIndex = Math.floor(
            Math.random() * availablePositions.length
          );
          const pos = availablePositions.splice(randIndex, 1)[0];

          let powerUpType = null;
          if (Math.random() < 0.15 && currentPowerUpPool.length > 0) {
            powerUpType =
              currentPowerUpPool[
                Math.floor(Math.random() * currentPowerUpPool.length)
              ];
          }

          let brickTypes = [];

          if (level >= 9) {
            brickTypes.push("double_armored");
          } else if (level >= 7) {
            brickTypes.push("armored");
          }

          let spikyChance = 0.08;
          if (level >= 8) {
            spikyChance = 0.15;
          }

          if (level >= 5 && Math.random() < spikyChance) {
            brickTypes = ["spiky"];
          } else {
            const maxModifiers = level >= 6 ? 2 : 1;
            let currentModifiers = brickTypes.length;

            const availableModifiers = [
              { type: "volatile", minLevel: 3, prob: 0.25 },
              { type: "regenerating", minLevel: 2, prob: 0.25 },
              { type: "armored", minLevel: 1, prob: 0.3 },
              { type: "double_armored", minLevel: 4, prob: 0.2 },
            ];

            for (const mod of availableModifiers) {
              if (
                currentModifiers < maxModifiers &&
                level >= mod.minLevel &&
                !brickTypes.includes(mod.type) &&
                Math.random() < mod.prob
              ) {
                if (
                  mod.type === "armored" &&
                  brickTypes.includes("double_armored")
                )
                  continue;
                if (
                  mod.type === "double_armored" &&
                  brickTypes.includes("armored")
                )
                  continue;

                brickTypes.push(mod.type);
                currentModifiers++;
              }
            }
          }

          if (
            brickTypes.includes("double_armored") &&
            brickTypes.includes("armored")
          ) {
            brickTypes.splice(brickTypes.indexOf("armored"), 1);
          }

          const newBrick = new Brick(
            pos.c * brickSize + 2,
            pos.r * brickSize + 2,
            1,
            powerUpType,
            brickTypes
          );
          newBricks.push(newBrick);
          healthToDistribute--;
        }

        while (healthToDistribute > 0) {
          const randomBrick =
            newBricks[Math.floor(Math.random() * newBricks.length)];
          randomBrick.health++;
          randomBrick.initialHealth++;
          healthToDistribute--;
        }

        if (
          newBricks.length > 0 &&
          !newBricks.some((b) => b.powerUp) &&
          currentPowerUpPool.length > 0
        ) {
          const randomBrick =
            newBricks[Math.floor(Math.random() * newBricks.length)];
          randomBrick.powerUp =
            currentPowerUpPool[
              Math.floor(Math.random() * currentPowerUpPool.length)
            ];
        }

        if (
          (playerPerk === "ghost" || playerPerk === "multiplier") &&
          newBricks.length > 0
        ) {
          newBricks[Math.floor(Math.random() * newBricks.length)].powerUp =
            playerPerk;
        }

        bricks.push(...newBricks);
        return totalHealth;
      }

      function setupLevel(levelIndex) {
        level = levelIndex;
        if (level >= levels.length) {
          gameState = "levelComplete";
          uiButtons = [];
          return;
        }

        ballsToLaunch = baseBallsToLaunch;
        playerDamage = basePlayerDamage;
        powerUpQueue = [];
        launchIndex = 0;
        launchTimer = 0;
        ballsReturned = 0;
        totalBallsLaunchedThisRound = 0;

        const levelData = levels[level];
        score = 0;
        bricks = [];
        balls = [];
        powerUps = [];
        endScreenListenerAdded = false;
        powerUpDamageStats = {};
        gameState = "waiting";
        totalHealthGenerated = 0;
        rowsGeneratedThisLevel = 0;

        levelTargetScore =
          levelData.rows * levelData.baseHealth +
          (levelData.healthIncrease * levelData.rows * (levelData.rows - 1)) /
            2;

        const initialRowCount = 2;
        for (let i = 0; i < initialRowCount; i++) {
          const healthForThisRow =
            levelData.baseHealth +
            rowsGeneratedThisLevel * levelData.healthIncrease;
          const newHealth = generateRows(
            1,
            Math.max(BRICK_COLUMNS, healthForThisRow)
          );
          totalHealthGenerated += newHealth;
          rowsGeneratedThisLevel++;
        }

        updateLaunchQueue();
        transitionTimer = TRANSITION_DURATION;
        gameState = "levelTransition";
      }

      function drawPredictedTrajectory() {
        const firstBallProps = currentLaunchQueue[0] || {};
        const simRadius = firstBallProps.isGiant
          ? ballRadius * 1.8
          : ballRadius;

        const simBall = {
          x: launchPosition.x,
          y: launchPosition.y,
          vx: Math.cos(aimAngle) * (canvas.height / 160),
          vy: Math.sin(aimAngle) * (canvas.height / 160),
          radius: simRadius,
        };

        const simBricks = bricks
          .filter((b) => !b.isBeingDestroyed)
          .map((b) => ({ ...b }));
        const totalRoundDamage = playerDamage * totalBallsLaunchedThisRound;
        let destroyedMarkers = [];

        ctx.beginPath();
        ctx.setLineDash([5, 10]);
        ctx.strokeStyle = "rgba(255, 255, 255, 0.5)";
        ctx.moveTo(simBall.x, simBall.y);

        const MAX_BOUNCES = 8;
        const MAX_STEPS = 1200;
        let bounces = 0;
        const isGhostPrediction =
          playerPerk === "ghost" || firstBallProps.powerUp === "ghost";

        for (let i = 0; i < MAX_STEPS && bounces < MAX_BOUNCES; i++) {
          simBall.x += simBall.vx;
          simBall.y += simBall.vy;

          let bouncedThisStep = false;

          if (
            simBall.x - simBall.radius <= 0 ||
            simBall.x + simBall.radius >= canvas.width
          ) {
            simBall.vx *= -1;
            simBall.x =
              simBall.x - simBall.radius <= 0
                ? simBall.radius
                : canvas.width - simBall.radius;
            bouncedThisStep = true;
          }
          if (simBall.y - simBall.radius <= 0) {
            simBall.vy *= -1;
            simBall.y = simBall.radius;
            bouncedThisStep = true;
          }

          for (let j = simBricks.length - 1; j >= 0; j--) {
            const brick = simBricks[j];
            const closestX = Math.max(
              brick.x,
              Math.min(simBall.x, brick.x + brick.width)
            );
            const closestY = Math.max(
              brick.y,
              Math.min(simBall.y, brick.y + brick.height)
            );

            if (
              Math.hypot(simBall.x - closestX, simBall.y - closestY) <
              simBall.radius
            ) {
              if (isGhostPrediction && bounces < 1) {
                continue;
              }

              if (totalRoundDamage >= brick.health) {
                destroyedMarkers.push({
                  x: brick.x + brick.width / 2,
                  y: brick.y + brick.height / 2,
                });
                simBricks.splice(j, 1);
                continue;
              }

              if (closestX === simBall.x) simBall.vy *= -1;
              else if (closestY === simBall.y) simBall.vx *= -1;
              else {
                simBall.vx *= -1;
                simBall.vy *= -1;
              }
              bouncedThisStep = true;
              break;
            }
          }

          ctx.lineTo(simBall.x, simBall.y);

          if (bouncedThisStep) {
            bounces++;
            if (bounces >= MAX_BOUNCES) {
              ctx.stroke();
              ctx.beginPath();
              ctx.arc(
                simBall.x,
                simBall.y,
                simBall.radius * 1.5,
                0,
                Math.PI * 2
              );
              ctx.fillStyle = "rgba(255, 255, 255, 0.5)";
              ctx.fill();
              break;
            }
          }

          if (simBall.y > canvas.height) break;
        }

        ctx.stroke();
        ctx.setLineDash([]);

        destroyedMarkers.forEach((marker) => {
          ctx.beginPath();
          ctx.strokeStyle = "rgba(255, 80, 80, 0.8)";
          ctx.lineWidth = 3;
          ctx.moveTo(marker.x - 5, marker.y - 5);
          ctx.lineTo(marker.x + 5, marker.y + 5);
          ctx.moveTo(marker.x + 5, marker.y - 5);
          ctx.lineTo(marker.x - 5, marker.y + 5);
          ctx.stroke();
        });
      }

      function createParticles(x, y, count, color = null) {
        for (let i = 0; i < count; i++) {
          const particleColor =
            color || `hsl(${Math.random() * 360}, 100%, 70%)`;
          particles.push(new Particle(x, y, particleColor));
        }
      }

      function shakeScreen(intensity) {
        screenShake.intensity = intensity;
        screenShake.duration = 170;
      }

      function update(deltaTime) {
        if (!deltaTime) return;

        if (
          gameState === "startScreen" ||
          gameState === "perkSelection" ||
          gameState === "gameOver" ||
          gameState === "levelComplete" ||
          gameState === "paused"
        ) {
          const uiElements = [...(powerUpChoices || []), ...(uiButtons || [])];
          uiElements.forEach((el) => {
            if (el.hoverProgress === undefined) el.hoverProgress = 0;
            const targetHover = el.isHovered ? 1 : 0;
            el.hoverProgress += (targetHover - el.hoverProgress) * 0.2;
            if (Math.abs(targetHover - el.hoverProgress) < 0.001)
              el.hoverProgress = targetHover;

            if (el.animProgress === undefined) el.animProgress = 0;
            const targetAnim = 1;
            el.animProgress += (targetAnim - el.animProgress) * 0.1;
            if (Math.abs(targetAnim - el.animProgress) < 0.001)
              el.animProgress = targetAnim;
          });
        }

        if (gameState === "paused") return;

        const speedMultiplier =
          isSpeedingUp && gameState === "shooting" ? SPEED_UP_MULTIPLIER : 1;
        const deltaFactor = (deltaTime / (1000 / 60)) * speedMultiplier;

        if (gameState === "shooting") {
          if (launchIndex < totalBallsLaunchedThisRound) {
            launchTimer += deltaTime;
            if (launchTimer >= LAUNCH_INTERVAL_MS) {
              launchTimer -= LAUNCH_INTERVAL_MS;
              const props = currentLaunchQueue[launchIndex];

              let currentAimAngle = aimAngle;
              let inaccuracy = 0;
              switch (props.powerUp) {
                case "giant":
                  inaccuracy = 0.02;
                  break;
                case "fire":
                  inaccuracy = 0.03;
                  break;
                case "scatter":
                  inaccuracy = 0.05;
                  break;
              }
              if (inaccuracy > 0) {
                currentAimAngle += (Math.random() - 0.5) * inaccuracy;
              }

              const newBall = new Ball(
                launchPosition.x,
                launchPosition.y,
                currentAimAngle
              );
              newBall.powerUp = props.powerUp;
              if (props.isSplit) newBall.canSplit = true;
              if (props.isGiant) newBall.radius = ballRadius * 1.8;
              balls.push(newBall);
              launchIndex++;
            }
          }

          for (let j = balls.length - 1; j >= 0; j--) {
            if (!balls[j].update(deltaFactor, deltaTime)) {
              if (!balls[j].isSplitBall) ballsReturned++;
              balls.splice(j, 1);
            }
          }

          powerUps.forEach((powerUp, index) => {
            powerUp.update(deltaFactor);
            if (powerUp.collected) {
              handlePowerUpCollection(powerUp);
              powerUps.splice(index, 1);
            } else if (powerUp.y - powerUp.radius > canvas.height) {
              powerUps.splice(index, 1);
            }
          });

          checkCollisions();

          if (
            balls.length === 0 &&
            powerUps.length === 0 &&
            ballsReturned >= totalBallsLaunchedThisRound
          ) {
            isSpeedingUp = false;
            isAiming = false;
            comboCount = 0;

            const allRowsGenerated =
              rowsGeneratedThisLevel >= levels[level].rows;

            if (bricks.length === 0 && allRowsGenerated) {
              uiButtons = [];
              gameState = "levelComplete";
              playSound("levelUp");
              return;
            } else {
              const screenWasCleared = bricks.length === 0 && !allRowsGenerated;
              gameState = "waiting";
              setTimeout(() => nextRound(screenWasCleared), 300);
            }
          }
        }

        bricks.forEach((b) => b.update(deltaTime));
        bricks = bricks.filter((b) => !b.isFullyDestroyed);

        visualEffects.forEach((effect, index) => {
          effect.duration -= deltaTime;
          effect.alpha = effect.duration / 420;
          if (effect.duration <= 0) visualEffects.splice(index, 1);
        });

        particles.forEach((p, index) => {
          p.update(deltaTime);
          if (p.alpha <= 0) particles.splice(index, 1);
        });

        floatingTexts.forEach((ft, index) => {
          ft.update(deltaTime);
          if (ft.duration <= 0) floatingTexts.splice(index, 1);
        });

        if (screenShake.duration > 0) {
          screenShake.duration -= deltaTime;
        }

        if (comboTimer > 0) {
          comboTimer -= deltaTime;
          if (comboTimer <= 0) {
            comboCount = 0;
          }
        }

        if (gameState === "levelTransition") {
          transitionTimer -= deltaTime;
          if (transitionTimer <= 0) {
            gameState = "aiming";
          }
        }
      }

      function handlePowerUpCollection(powerUp) {
        let text = "";
        let color = "white";
        switch (powerUp.type) {
          case "extraBall":
            ballsToLaunch++;
            text = "+1 Bola";
            color = "#32CD32";
            break;
          case "laser":
            powerUpQueue.push("laser");
            text = "Bola Laser!";
            color = "#FF00FF";
            break;
          case "fire":
            powerUpQueue.push("fire");
            text = "Bola de Fogo";
            color = "#FF4500";
            break;
          case "giant":
            powerUpQueue.push("giant");
            text = "Bola Gigante";
            color = "#1E90FF";
            break;
          case "scatter":
            powerUpQueue.push("scatter");
            text = "Chuva de Bolas";
            color = "#FFFF00";
            break;
          case "ghost":
            powerUpQueue.push("ghost");
            text = "Bola Fantasma";
            color = "#E6E6FA";
            break;
          case "multiplier":
            powerUpQueue.push("multiplier");
            text = "Multiplicador";
            color = "#800080";
            break;
          case "damageUp":
            playerDamage++;
            text = "+1 Dano";
            color = "#FF8C00";
            break;
          case "debuff":
            powerUpQueue.push("debuff");
            text = "Enfraquecer";
            color = "#8A2BE2";
            break;
        }
        floatingTexts.push(
          new FloatingText(powerUp.x, powerUp.y, text, color, canvas.width / 25)
        );
        if (powerUp.type !== "laser") playSound("powerup");
        updateLaunchQueue();
      }

      function draw() {
        const isGameActive =
          gameState !== "startScreen" &&
          gameState !== "gameOver" &&
          gameState !== "levelComplete" &&
          gameState !== "perkSelection";

        ctx.fillStyle = "#121212";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        if (!isGameActive || gameState === "paused") {
          drawBackground();
        }

        ctx.save();

        if (
          isGameActive &&
          gameState !== "paused" &&
          screenShake.duration > 0
        ) {
          const shakeX = (Math.random() - 0.5) * screenShake.intensity;
          const shakeY = (Math.random() - 0.5) * screenShake.intensity;
          ctx.translate(shakeX, shakeY);
        }

        if (isGameActive) {
          drawBackground();
          drawGameElements();
          if (gameState === "levelTransition") {
            drawLevelTransitionScreen();
          }
        } else if (gameState === "startScreen") {
          drawStartScreen();
        } else if (gameState === "perkSelection") {
          drawPerkSelectionScreen();
        } else if (gameState === "gameOver" || gameState === "levelComplete") {
          drawEndScreen();
        }

        if (gameState === "paused") {
          drawPauseScreen();
        }

        ctx.restore();
        updateInfoPanel();
      }

      function drawGameElements() {
        if (gameState === "aiming" && isAiming) {
          drawPredictedTrajectory();
        }
        bricks.forEach((b) => b.draw());
        powerUps.forEach((p) => p.draw());
        balls.forEach((b) => b.draw());
        particles.forEach((p) => p.draw());
        floatingTexts.forEach((ft) => ft.draw());
        visualEffects.forEach(drawVisualEffect);
        if (
          gameState === "aiming" ||
          gameState === "shooting" ||
          gameState === "round_ending" ||
          gameState === "waiting" ||
          gameState === "levelTransition"
        ) {
          drawLauncherQueue();
        }
        drawCombo();
      }

      function drawCombo() {
        if (comboCount < 2) return;

        const progress = Math.min(1, comboTimer / COMBO_TIMEOUT);
        const alpha =
          Math.min(1, comboCount / 10) * Math.sin(progress * Math.PI) * 0.7;
        const scale =
          1 + (1 - progress) * 0.15 + Math.min(0.25, comboCount * 0.003);

        ctx.save();
        ctx.globalAlpha = alpha;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";

        const comboX = canvas.width / 2;
        const comboY = canvas.height / 2;

        ctx.translate(comboX, comboY);
        ctx.scale(scale, scale);

        const hue = (comboCount * 10) % 360;
        const comboText = `COMBO x${comboCount}`;
        ctx.fillStyle = `hsl(${hue}, 90%, 70%)`;
        const baseFontSize = canvas.width / 14;
        const maxFontSize = canvas.width / 9;
        const fontSize = Math.min(
          maxFontSize,
          baseFontSize + comboCount * 0.15
        );
        ctx.font = `bold ${fontSize}px 'Segoe UI', sans-serif`;
        ctx.shadowColor = "black";
        ctx.shadowBlur = 15;
        ctx.lineWidth = 4;
        ctx.strokeStyle = "rgba(0,0,0,0.5)";

        ctx.strokeText(comboText, 0, 0);
        ctx.fillText(comboText, 0, 0);

        let comboAdjective = "";
        if (comboCount >= 50) comboAdjective = "DESTRUIDOR!";
        else if (comboCount >= 30) comboAdjective = "IMPLACÁVEL!";
        else if (comboCount >= 15) comboAdjective = "FANTÁSTICO!";
        else if (comboCount >= 5) comboAdjective = "Belo combo!";

        if (comboAdjective) {
          ctx.font = `bold ${canvas.width / 18}px 'Segoe UI', sans-serif`;
          const adjY = canvas.height / 10;
          ctx.fillStyle = `hsl(${hue}, 90%, 85%)`;
          ctx.strokeText(comboAdjective, 0, adjY);
          ctx.fillText(comboAdjective, 0, adjY);
        }

        ctx.restore();
      }

      function drawLevelTransitionScreen() {
        const elapsedTime = TRANSITION_DURATION - transitionTimer;
        const fadeInTime = 800;
        const fadeOutTime = 800;
        const fadeOutStartTime = TRANSITION_DURATION - fadeOutTime;

        let alpha;
        if (elapsedTime < fadeInTime) {
          alpha = elapsedTime / fadeInTime;
        } else if (elapsedTime > fadeOutStartTime) {
          alpha = (TRANSITION_DURATION - elapsedTime) / fadeOutTime;
        } else {
          alpha = 1;
        }

        const scale = 0.9 + alpha * 0.1;

        ctx.save();

        ctx.fillStyle = `rgba(0, 0, 0, ${alpha * 0.8})`;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        ctx.globalAlpha = alpha;
        ctx.translate(canvas.width / 2, canvas.height / 2);
        ctx.scale(scale, scale);

        ctx.fillStyle = "white";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.font = `bold ${canvas.width / 8}px 'Segoe UI', sans-serif`;
        ctx.shadowColor = "black";
        ctx.shadowBlur = 15;
        ctx.fillText(`Nível ${level + 1}`, 0, -canvas.height * 0.25);

        let newBrickInfo = null;
        switch (level) {
          case 1:
            newBrickInfo = {
              types: ["armored"],
              name: "Bloco Blindado",
              description: "Absorve o primeiro impacto.",
              subTitle: "NOVO INIMIGO:",
            };
            break;
          case 2:
            newBrickInfo = {
              types: ["regenerating"],
              name: "Bloco Regenerativo",
              description: "Cura vida entre as rodadas.",
              subTitle: "NOVO INIMIGO:",
            };
            break;
          case 3:
            newBrickInfo = {
              types: ["volatile"],
              name: "Bloco Volátil",
              description: "Explode ao ser destruído.",
              subTitle: "NOVO INIMIGO:",
            };
            break;
          case 4:
            newBrickInfo = {
              types: ["double_armored"],
              name: "Bloco Super Blindado",
              description: "Absorve dois impactos.",
              subTitle: "NOVO INIMIGO:",
            };
            break;
          case 5:
            newBrickInfo = {
              types: ["spiky"],
              name: "Bloco de Espinhos",
              description: "Destrói a bola no impacto.",
              subTitle: "NOVO INIMIGO:",
            };
            break;
          case 6:
            newBrickInfo = {
              types: ["armored", "volatile"],
              name: "Blocos Híbridos",
              description: "Blocos agora podem ter duas modificações.",
              subTitle: "NOVO INIMIGO:",
            };
            break;
          case 7:
            newBrickInfo = {
              types: ["armored"],
              name: "Onda Blindada",
              description: "Todos os blocos agora nascem blindados.",
              subTitle: "AVISO:",
            };
            break;
          case 8:
            newBrickInfo = {
              types: ["spiky"],
              name: "Ameaça de Espinhos",
              description: "Blocos de espinhos se tornam mais comuns.",
              subTitle: "ALERTA:",
            };
            break;
          case 9:
            newBrickInfo = {
              types: ["double_armored"],
              name: "Fortaleza Impenetrável",
              description: "Todos os blocos agora nascem com blindagem dupla.",
              subTitle: "AVISO:",
            };
            break;
        }

        if (newBrickInfo) {
          ctx.font = `bold ${canvas.width / 22}px 'Segoe UI', sans-serif`;
          ctx.fillStyle = "#cccccc";
          ctx.fillText(newBrickInfo.subTitle, 0, -canvas.height * 0.1);

          const sampleBrickSize = canvas.width / 8;
          const sampleBrickX = -sampleBrickSize / 2;
          const sampleBrickY = -canvas.height * 0.05;
          const tempBrick = new Brick(
            sampleBrickX,
            sampleBrickY,
            1,
            null,
            newBrickInfo.types
          );
          tempBrick.width = sampleBrickSize;
          tempBrick.height = sampleBrickSize;
          const originalBrickSize = brickSize;
          brickSize = sampleBrickSize;

          ctx.save();
          ctx.translate(sampleBrickX, sampleBrickY);
          tempBrick.x = 0;
          tempBrick.y = 0;
          tempBrick.drawContent();
          ctx.restore();

          brickSize = originalBrickSize;

          ctx.font = `bold ${canvas.width / 18}px 'Segoe UI', sans-serif`;
          ctx.fillStyle = "white";
          ctx.fillText(
            newBrickInfo.name,
            0,
            sampleBrickY + sampleBrickSize + canvas.height * 0.04
          );

          ctx.font = `normal ${canvas.width / 28}px 'Segoe UI', sans-serif`;
          ctx.fillStyle = "#FFD700";
          ctx.fillText(
            newBrickInfo.description,
            0,
            sampleBrickY + sampleBrickSize + canvas.height * 0.1
          );
        }

        ctx.restore();
      }

      function drawVisualEffect(effect) {
        const color = "#FF00FF";
        ctx.save();
        ctx.globalAlpha = Math.max(0, effect.alpha);
        ctx.shadowColor = color;

        if (effect.type === "laser_h") {
          ctx.shadowBlur = 20;
          ctx.fillStyle = color;
          ctx.fillRect(0, effect.y - 3, canvas.width, 6);
          ctx.shadowBlur = 10;
          ctx.fillStyle = "white";
          ctx.fillRect(0, effect.y - 1, canvas.width, 2);
        } else if (effect.type === "laser_v") {
          ctx.shadowBlur = 20;
          ctx.fillStyle = color;
          ctx.fillRect(effect.x - 3, 0, 6, canvas.height);
          ctx.shadowBlur = 10;
          ctx.fillStyle = "white";
          ctx.fillRect(effect.x - 1, 0, 2, canvas.height);
        } else if (effect.type === "laser_d") {
          ctx.translate(effect.x, effect.y);
          ctx.rotate(effect.isForward ? Math.PI / 4 : -Math.PI / 4);
          ctx.shadowBlur = 20;
          ctx.fillStyle = color;
          ctx.fillRect(canvas.width * -1.5, -3, canvas.width * 3, 6);
          ctx.shadowBlur = 10;
          ctx.fillStyle = "white";
          ctx.fillRect(canvas.width * -1.5, -1, canvas.width * 3, 2);
        }
        ctx.restore();
      }

      function drawLauncherQueue() {
        if (currentLaunchQueue.length === 0 || gameState === "waiting") return;

        const animationProgress =
          gameState === "shooting"
            ? Math.min(1, launchTimer / LAUNCH_INTERVAL_MS)
            : 0;
        const queue = currentLaunchQueue.slice(launchIndex);

        if (queue.length === 0) return;

        const powerUpCounts = {};
        let hasNormalBall = false;

        queue.forEach((item) => {
          if (item.powerUp) {
            powerUpCounts[item.powerUp] =
              (powerUpCounts[item.powerUp] || 0) + 1;
          } else {
            hasNormalBall = true;
          }
        });

        let displayQueue = Object.entries(powerUpCounts);
        if (hasNormalBall) {
          const normalBallCount = queue.filter((item) => !item.powerUp).length;
          displayQueue.unshift(["normal", normalBallCount]);
        }

        const queueBallRadius = ballRadius * 1.1;
        const itemWidth = queueBallRadius * 2.2;
        const totalWidth = displayQueue.length * itemWidth;
        let startX = launchPosition.x - totalWidth / 2 + itemWidth / 2;

        if (gameState === "shooting") {
          const firstType = queue[0].powerUp || "normal";
          const countOfFirstType =
            powerUpCounts[firstType] ||
            (firstType === "normal"
              ? displayQueue.find((d) => d[0] === "normal")[1]
              : 0);

          if (countOfFirstType === 1) {
            startX -= (itemWidth * animationProgress) / 2;
          }
        }

        let currentX = startX;

        displayQueue.forEach(([type, count]) => {
          ctx.save();
          ctx.translate(currentX, launchPosition.y);

          ctx.beginPath();
          ctx.arc(0, 0, queueBallRadius, 0, Math.PI * 2);
          ctx.fillStyle = "rgba(40,40,40,.8)";
          ctx.fill();
          ctx.strokeStyle = "white";
          ctx.lineWidth = 1.5;
          ctx.stroke();

          drawPowerUpSymbol(ctx, type, 0, 0, queueBallRadius);

          if (count > 0) {
            ctx.fillStyle = "#FFD700";
            ctx.font = `bold ${queueBallRadius * 0.9}px 'Segoe UI', sans-serif`;
            ctx.textAlign = "right";
            ctx.textBaseline = "bottom";
            ctx.strokeStyle = "black";
            ctx.lineWidth = 3;
            ctx.strokeText(`x${count}`, queueBallRadius, queueBallRadius);
            ctx.fillText(`x${count}`, queueBallRadius, queueBallRadius);
          }

          ctx.restore();
          currentX += itemWidth;
        });
      }

      function drawPowerUpSymbol(context, type, x, y, radius, animate = false) {
        const s = radius * 0.8;
        context.save();
        context.translate(x, y);
        context.lineWidth = radius / 6;
        context.lineJoin = "round";
        context.lineCap = "round";

        const time = Date.now();
        const animCycle = animate ? Math.sin(time / 600) : 0;
        const normalizedAnimCycle = (animCycle + 1) / 2;

        switch (type) {
          case "normal":
            context.strokeStyle = "#cccccc";
            context.beginPath();
            context.arc(0, 0, s * 0.7, 0, Math.PI * 2);
            context.stroke();
            break;
          case "extraBall":
            context.strokeStyle = "#32CD32";
            context.beginPath();
            context.arc(0, 0, s * 0.8, 0, Math.PI * 2);
            context.stroke();
            if (animate) {
              const colorPulse = Math.abs(animCycle);
              context.fillStyle = `rgb(${90 + 100 * colorPulse}, ${
                220 - 100 * colorPulse
              }, ${90 + 100 * colorPulse})`;
            } else {
              context.fillStyle = "#32CD32";
            }
            context.fillRect(-s * 0.15, -s * 0.5, s * 0.3, s * 1);
            context.fillRect(-s * 0.5, -s * 0.15, s * 1, s * 0.3);
            break;
          case "fire":
            if (animate) {
              context.save();
              const auraAlpha = 0.1 + normalizedAnimCycle * 0.3;
              context.globalAlpha = auraAlpha;
              context.fillStyle = "#FF9800";
              context.beginPath();
              context.moveTo(0, -s * 1.2);
              context.bezierCurveTo(s * 1.2, -s, s * 0.8, s * 0.3, s, s * 0.8);
              context.bezierCurveTo(
                s * 0.6,
                s * 1.2,
                -s * 0.6,
                s * 1.2,
                -s,
                s * 0.8
              );
              context.bezierCurveTo(
                -s * 0.8,
                s * 0.3,
                -s * 1.2,
                -s,
                0,
                -s * 1.2
              );
              context.fill();
              context.restore();
            }
            context.fillStyle = "#FF4500";
            context.beginPath();
            context.moveTo(0, -s);
            context.bezierCurveTo(
              s,
              -s * 0.8,
              s * 0.6,
              s * 0.1,
              s * 0.8,
              s * 0.6
            );
            context.bezierCurveTo(s * 0.5, s, -s * 0.5, s, -s * 0.8, s * 0.6);
            context.bezierCurveTo(-s * 0.6, s * 0.1, -s, -s * 0.8, 0, -s);
            context.fill();
            break;
          case "giant":
            if (animate) {
              const scale = 1 + animCycle * 0.1;
              context.scale(scale, scale);
            }
            context.fillStyle = "#1E90FF";
            context.beginPath();
            context.arc(0, 0, s, 0, Math.PI * 2);
            context.fill();
            context.fillStyle = "rgba(255,255,255,0.5)";
            context.beginPath();
            context.arc(-s * 0.3, -s * 0.3, s * 0.3, 0, Math.PI * 2);
            context.fill();
            break;
          case "laser":
          case "precisãolaser":
            context.strokeStyle = "#FF00FF";
            for (let i = 0; i < 8; i++) {
              const angle = (i / 8) * Math.PI * 2;
              const startRadius = s * 0.4;
              const endRadius = animate
                ? s * 0.7 + normalizedAnimCycle * s * 0.3
                : s;
              context.save();
              context.rotate(angle);
              context.beginPath();
              context.moveTo(0, -startRadius);
              context.lineTo(0, -endRadius);
              context.stroke();
              context.restore();
            }
            break;
          case "scatter":
            context.fillStyle = "#FFFF00";
            context.beginPath();
            context.arc(0, -s * 0.3, s * 0.5, 0, Math.PI * 2);
            context.fill();

            if (animate) {
              const cycleDuration = 1500;
              const phaseDuration = cycleDuration / 3;
              const cycleTime = time % cycleDuration;

              if (cycleTime > phaseDuration) {
                context.beginPath();
                context.arc(-s * 0.6, s * 0.6, s * 0.3, 0, Math.PI * 2);
                context.fill();
              }
              if (cycleTime > phaseDuration * 2) {
                context.beginPath();
                context.arc(s * 0.6, s * 0.6, s * 0.3, 0, Math.PI * 2);
                context.fill();
              }
            } else {
              context.beginPath();
              context.arc(-s * 0.6, s * 0.6, s * 0.3, 0, Math.PI * 2);
              context.fill();
              context.beginPath();
              context.arc(s * 0.6, s * 0.6, s * 0.3, 0, Math.PI * 2);
              context.fill();
            }
            break;
          case "ghost":
            if (animate) {
              context.globalAlpha = 0.5 + normalizedAnimCycle * 0.5;
            }
            context.strokeStyle = "#E6E6FA";
            context.beginPath();
            context.arc(0, 0, s * 0.8, 0, Math.PI, true);
            context.lineTo(-s * 0.8, s * 0.5);
            context.quadraticCurveTo(-s * 0.4, s * 0.2, 0, s * 0.5);
            context.quadraticCurveTo(s * 0.4, s * 0.2, s * 0.8, s * 0.5);
            context.lineTo(s * 0.8, 0);
            context.stroke();
            break;
          case "multiplier":
            context.strokeStyle = "#8A2BE2";
            const separation = animate
              ? s * 0.1 + normalizedAnimCycle * s * 0.3
              : s * 0.3;
            context.beginPath();
            context.arc(-separation, 0, s * 0.6, 0, Math.PI * 2);
            context.stroke();
            context.beginPath();
            context.arc(separation, 0, s * 0.6, 0, Math.PI * 2);
            context.stroke();
            break;
          case "damageUp":
            context.strokeStyle = "#FF8C00";
            if (animate) {
              const yOffset = animCycle * s * 0.2;
              context.translate(0, yOffset);
            }
            context.beginPath();
            context.moveTo(0, -s);
            context.lineTo(s * 0.8, s * 0.8);
            context.lineTo(-s * 0.8, s * 0.8);
            context.closePath();
            context.stroke();
            break;
          case "debuff":
            context.strokeStyle = "#8A2BE2";
            if (animate) {
              const yOffset = -animCycle * s * 0.2;
              context.translate(0, yOffset);
            }
            context.beginPath();
            context.moveTo(0, s);
            context.lineTo(s * 0.8, -s * 0.8);
            context.lineTo(-s * 0.8, -s * 0.8);
            context.closePath();
            context.stroke();
            break;
        }
        context.restore();
      }

      function drawRoundRect(ctx, x, y, width, height, radius) {
        if (width < 2 * radius) radius = width / 2;
        if (height < 2 * radius) radius = height / 2;
        ctx.beginPath();
        ctx.moveTo(x + radius, y);
        ctx.arcTo(x + width, y, x + width, y + height, radius);
        ctx.arcTo(x + width, y + height, x, y + height, radius);
        ctx.arcTo(x, y + height, x, y, radius);
        ctx.arcTo(x, y, x + width, y, radius);
        ctx.closePath();
        return ctx;
      }

      function wrapAndDrawText(ctx, text, x, y, maxWidth, lineHeight) {
        const lines = text.split("\n");
        let currentY = y;
        lines.forEach((lineOfText) => {
          let words = lineOfText.split(" ");
          let currentLine = words[0] || "";

          for (let i = 1; i < words.length; i++) {
            let word = words[i];
            let testLine = currentLine + " " + word;
            let metrics = ctx.measureText(testLine);
            let testWidth = metrics.width;
            if (testWidth > maxWidth && i > 0) {
              ctx.fillText(currentLine, x, currentY);
              currentY += lineHeight;
              currentLine = word;
            } else {
              currentLine = testLine;
            }
          }
          ctx.fillText(currentLine, x, currentY);
          currentY += lineHeight;
        });
      }

      function drawStartScreen() {
        ctx.filter = "blur(8px)";
        ctx.drawImage(canvas, 0, 0);
        ctx.filter = "none";

        const titleText = "Escolha uma:";
        ctx.fillStyle = "rgba(255, 255, 255, 0.95)";
        ctx.font = `bold ${Math.min(
          canvas.width / 12,
          50
        )}px 'Segoe UI', sans-serif`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.shadowColor = "black";
        ctx.shadowBlur = 10;
        ctx.fillText(titleText, canvas.width / 2, canvas.height * 0.15);
        ctx.shadowBlur = 0;

        powerUpChoices.forEach((choice) => {
          const animProgress = choice.animProgress || 0;
          const hoverProgress = choice.hoverProgress || 0;

          const currentY =
            choice.startY + (choice.targetY - choice.startY) * animProgress;
          const scale = 1 + hoverProgress * 0.05;
          const opacity = animProgress;

          ctx.save();
          ctx.globalAlpha = opacity;
          ctx.translate(
            choice.x + choice.width / 2,
            currentY + choice.height / 2
          );
          ctx.scale(scale, scale);
          ctx.translate(
            -(choice.x + choice.width / 2),
            -(currentY + choice.height / 2)
          );

          const cardGradient = ctx.createLinearGradient(
            choice.x,
            currentY,
            choice.x,
            currentY + choice.height
          );
          cardGradient.addColorStop(0, "rgba(45, 45, 65, 0.9)");
          cardGradient.addColorStop(1, "rgba(25, 25, 45, 0.9)");
          ctx.fillStyle = cardGradient;
          drawRoundRect(
            ctx,
            choice.x,
            currentY,
            choice.width,
            choice.height,
            20
          ).fill();

          const r = parseInt(choice.color.slice(1, 3), 16);
          const g = parseInt(choice.color.slice(3, 5), 16);
          const b = parseInt(choice.color.slice(5, 7), 16);
          ctx.shadowColor = `rgba(${r},${g},${b},0.8)`;
          ctx.shadowBlur = hoverProgress * 35;
          ctx.strokeStyle = `rgba(${r},${g},${b}, ${
            0.2 + hoverProgress * 0.8
          })`;
          ctx.lineWidth = 1.5 + hoverProgress * 2.5;
          drawRoundRect(
            ctx,
            choice.x,
            currentY,
            choice.width,
            choice.height,
            20
          ).stroke();

          ctx.shadowBlur = 0;

          const iconRadius = choice.width / 5;
          drawPowerUpSymbol(
            ctx,
            choice.icon,
            choice.x + choice.width / 2,
            currentY + choice.height * 0.28,
            iconRadius,
            true
          );

          ctx.fillStyle = "white";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          const cardTitleFontSize = Math.min(choice.width / 6, 32);
          ctx.font = `bold ${cardTitleFontSize}px 'Segoe UI', sans-serif`;
          ctx.fillText(
            choice.title,
            choice.x + choice.width / 2,
            currentY + choice.height * 0.58
          );

          ctx.fillStyle = "#ccc";
          const cardDescFontSize = Math.min(choice.width / 9, 18);
          ctx.font = `normal ${cardDescFontSize}px 'Segoe UI', sans-serif`;
          wrapAndDrawText(
            ctx,
            choice.description,
            choice.x + choice.width / 2,
            currentY + choice.height * 0.75,
            choice.width * 0.85,
            cardDescFontSize * 1.3
          );

          ctx.restore();
        });
      }

      function drawEndScreen() {
        ctx.filter = "blur(8px)";
        ctx.drawImage(
          canvas,
          0,
          0,
          canvas.width,
          canvas.height,
          0,
          0,
          canvas.width,
          canvas.height
        );
        ctx.filter = "none";

        const animProgress = uiButtons[0]?.animProgress || 0;

        ctx.save();
        ctx.globalAlpha = animProgress;
        ctx.translate(0, (1 - animProgress) * 50);

        const isWin = gameState === "levelComplete";
        const isFinalWin = isWin && level >= levels.length - 1;
        const sortedStats = Object.entries(powerUpDamageStats)
          .sort(([, a], [, b]) => b - a)
          .filter(([source, damage]) => damage > 0);
        const showStats = isWin && sortedStats.length > 0;

        let panelHeight = canvas.height * 0.55;
        if (showStats && !isFinalWin) {
          panelHeight = canvas.height * 0.8;
        }

        const panelWidth = canvas.width * 0.85;
        const panelX = (canvas.width - panelWidth) / 2;
        const panelY = (canvas.height - panelHeight) / 2;

        const panelGrad = ctx.createLinearGradient(
          0,
          panelY,
          0,
          panelY + panelHeight
        );
        panelGrad.addColorStop(0, "rgba(45, 45, 65, 0.9)");
        panelGrad.addColorStop(1, "rgba(25, 25, 45, 0.9)");
        ctx.fillStyle = panelGrad;
        drawRoundRect(ctx, panelX, panelY, panelWidth, panelHeight, 20).fill();

        ctx.strokeStyle = isWin
          ? "rgba(0, 255, 127, 0.5)"
          : "rgba(255, 69, 0, 0.5)";
        ctx.lineWidth = 2;
        drawRoundRect(
          ctx,
          panelX,
          panelY,
          panelWidth,
          panelHeight,
          20
        ).stroke();

        let titleText = isFinalWin
          ? "VOCÊ VENCEU!"
          : isWin
          ? "NÍVEL COMPLETO!"
          : "GAME OVER";
        ctx.fillStyle = isWin ? "#00FF7F" : "#FF4500";
        ctx.font = `bold ${canvas.width / 12}px 'Segoe UI', sans-serif`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.shadowColor = "black";
        ctx.shadowBlur = 8;
        ctx.fillText(titleText, canvas.width / 2, panelY + panelHeight * 0.12);
        ctx.shadowBlur = 0;

        let currentY = panelY + panelHeight * 0.25;

        if (isFinalWin) {
          ctx.fillStyle = "white";
          ctx.font = `bold ${canvas.width / 22}px 'Segoe UI', sans-serif`;
          ctx.fillText(
            "Parabéns!",
            canvas.width / 2,
            panelY + panelHeight * 0.45
          );
        } else {
          ctx.fillStyle = "white";
          ctx.font = `bold ${canvas.width / 24}px 'Segoe UI', sans-serif`;
          ctx.fillText(`Pontuação: ${score}`, canvas.width / 2, currentY);
          currentY += canvas.height * 0.08;
        }

        if (showStats && !isFinalWin) {
          ctx.font = `bold ${canvas.width / 28}px 'Segoe UI', sans-serif`;
          ctx.fillStyle = "#ccc";
          ctx.fillText("Relatório de Dano:", canvas.width / 2, currentY);
          currentY += canvas.height * 0.05;
          const statsStartX = panelX + panelWidth * 0.1;
          const statsWidth = panelWidth * 0.8;
          const availableHeight = panelY + panelHeight * 0.85 - currentY;
          const lineHeight = Math.min(
            availableHeight / Math.max(1, sortedStats.length),
            canvas.height * 0.06
          );

          sortedStats.forEach((stat, index) => {
            const [source, damage] = stat;
            const itemY = currentY + index * lineHeight;
            if (itemY > panelY + panelHeight * 0.8) return;
            const iconName =
              Object.keys(powerUpDisplayNames)
                .find((key) => powerUpDisplayNames[key] === source)
                ?.toLowerCase() || source.toLowerCase();
            const displayName = powerUpDisplayNames[source] || source;
            drawPowerUpSymbol(
              ctx,
              iconName,
              statsStartX,
              itemY,
              canvas.width / 45,
              true
            );
            ctx.textAlign = "left";
            ctx.textBaseline = "middle";
            ctx.fillStyle = "#ddd";
            ctx.font = `normal ${canvas.width / 32}px 'Segoe UI', sans-serif`;
            ctx.fillText(displayName, statsStartX + canvas.width * 0.08, itemY);
            ctx.textAlign = "right";
            ctx.fillStyle = "#FFD700";
            ctx.font = `bold ${canvas.width / 32}px 'Segoe UI', sans-serif`;
            ctx.fillText(damage, statsStartX + statsWidth, itemY);
          });
        }
        ctx.restore();

        if (uiButtons.length === 0) {
          const buttonHeight =
            panelHeight * 0.12 > 55 ? 55 : panelHeight * 0.12;
          const buttonWidth = panelWidth * 0.7;
          const buttonX = panelX + (panelWidth - buttonWidth) / 2;
          let buttonY =
            panelY + panelHeight - buttonHeight - panelHeight * 0.07;
          let buttonConfig = {};
          if (isFinalWin) {
            buttonConfig = {
              text: "Jogar Novamente",
              color: "#32CD32",
              onClick: () => window.location.reload(),
            };
          } else if (isWin) {
            buttonConfig = {
              text: "Escolher Melhoria",
              color: "#1E90FF",
              onClick: () => setupPerkSelectionScreen(level + 1),
            };
          } else {
            buttonConfig = {
              text: "Tentar Novamente",
              color: "#FF4500",
              onClick: () => window.location.reload(),
            };
          }
          uiButtons.push({
            x: buttonX,
            y: buttonY,
            width: buttonWidth,
            height: buttonHeight,
            ...buttonConfig,
          });
        }

        uiButtons.forEach((button) => {
          const hoverProgress = button.hoverProgress || 0;
          const scale = 1 + hoverProgress * 0.03;

          ctx.save();
          ctx.globalAlpha = animProgress;
          ctx.translate(
            button.x + button.width / 2,
            button.y + button.height / 2
          );
          ctx.scale(scale, scale);
          ctx.translate(
            -(button.x + button.width / 2),
            -(button.y + button.height / 2)
          );

          ctx.shadowColor = button.color;
          ctx.shadowBlur = hoverProgress * 25;

          const btnGrad = ctx.createLinearGradient(
            button.x,
            button.y,
            button.x,
            button.y + button.height
          );
          btnGrad.addColorStop(0, "rgba(80, 80, 110, 0.8)");
          btnGrad.addColorStop(1, "rgba(60, 60, 90, 0.8)");
          ctx.fillStyle = btnGrad;
          drawRoundRect(
            ctx,
            button.x,
            button.y,
            button.width,
            button.height,
            12
          ).fill();

          const r = parseInt(button.color.slice(1, 3), 16);
          const g = parseInt(button.color.slice(3, 5), 16);
          const b = parseInt(button.color.slice(5, 7), 16);
          ctx.strokeStyle = `rgba(${r},${g},${b}, ${
            0.5 + hoverProgress * 0.5
          })`;
          ctx.lineWidth = 2 + hoverProgress * 1.5;
          drawRoundRect(
            ctx,
            button.x,
            button.y,
            button.width,
            button.height,
            12
          ).stroke();

          ctx.shadowBlur = 0;

          ctx.fillStyle = "white";
          ctx.font = `bold ${canvas.width / 25}px 'Segoe UI', sans-serif`;
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.shadowColor = "black";
          ctx.shadowBlur = 4;
          ctx.fillText(
            button.text,
            button.x + button.width / 2,
            button.y + button.height / 2
          );
          ctx.restore();
        });
      }

      function drawPauseScreen() {
        ctx.filter = "blur(8px)";
        ctx.drawImage(canvas, 0, 0);
        ctx.filter = "none";

        const animProgress = uiButtons[0]?.animProgress || 0;

        const panelWidth = canvas.width * 0.8;
        const panelHeight = canvas.height * 0.4;
        const panelX = (canvas.width - panelWidth) / 2;
        const panelY = (canvas.height - panelHeight) / 2;

        ctx.save();
        ctx.globalAlpha = animProgress;
        ctx.translate(panelX + panelWidth / 2, panelY + panelHeight / 2);
        ctx.scale(0.8 + animProgress * 0.2, 0.8 + animProgress * 0.2);
        ctx.translate(-(panelX + panelWidth / 2), -(panelY + panelHeight / 2));

        const panelGrad = ctx.createLinearGradient(
          0,
          panelY,
          0,
          panelY + panelHeight
        );
        panelGrad.addColorStop(0, "rgba(45, 45, 65, 0.9)");
        panelGrad.addColorStop(1, "rgba(25, 25, 45, 0.9)");
        ctx.fillStyle = panelGrad;
        drawRoundRect(ctx, panelX, panelY, panelWidth, panelHeight, 20).fill();

        ctx.strokeStyle = "rgba(255, 255, 255, 0.3)";
        ctx.lineWidth = 2;
        drawRoundRect(
          ctx,
          panelX,
          panelY,
          panelWidth,
          panelHeight,
          20
        ).stroke();

        ctx.fillStyle = "white";
        ctx.font = `bold ${canvas.width / 12}px 'Segoe UI', sans-serif`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.shadowColor = "black";
        ctx.shadowBlur = 8;
        ctx.fillText("PAUSADO", canvas.width / 2, panelY + panelHeight * 0.3);
        ctx.shadowBlur = 0;

        ctx.restore();

        if (uiButtons.length === 0) {
          const buttonWidth = panelWidth * 0.6;
          const buttonHeight = panelHeight * 0.2;
          const buttonX = panelX + (panelWidth - buttonWidth) / 2;
          const gap = panelHeight * 0.1;
          const resumeButton = {
            x: buttonX,
            y: panelY + panelHeight * 0.45,
            width: buttonWidth,
            height: buttonHeight,
            text: "Continuar",
            color: "#32CD32",
            onClick: unpauseGame,
          };
          const restartButton = {
            x: buttonX,
            y: resumeButton.y + buttonHeight + gap,
            width: buttonWidth,
            height: buttonHeight,
            text: "Reiniciar",
            color: "#FF4500",
            onClick: () => {
              window.location.reload();
            },
          };
          uiButtons.push(resumeButton, restartButton);
        }

        uiButtons.forEach((button) => {
          const hoverProgress = button.hoverProgress || 0;
          const scale = 1 + hoverProgress * 0.05;

          ctx.save();
          ctx.globalAlpha = animProgress;
          ctx.translate(
            button.x + button.width / 2,
            button.y + button.height / 2
          );
          ctx.scale(scale, scale);
          ctx.translate(
            -(button.x + button.width / 2),
            -(button.y + button.height / 2)
          );

          ctx.shadowColor = button.color;
          ctx.shadowBlur = hoverProgress * 20;

          const btnGrad = ctx.createLinearGradient(
            button.x,
            button.y,
            button.x,
            button.y + button.height
          );
          btnGrad.addColorStop(0, "rgba(80, 80, 110, 0.8)");
          btnGrad.addColorStop(1, "rgba(60, 60, 90, 0.8)");
          ctx.fillStyle = btnGrad;
          drawRoundRect(
            ctx,
            button.x,
            button.y,
            button.width,
            button.height,
            10
          ).fill();

          const r = parseInt(button.color.slice(1, 3), 16);
          const g = parseInt(button.color.slice(3, 5), 16);
          const b = parseInt(button.color.slice(5, 7), 16);
          ctx.strokeStyle = `rgba(${r},${g},${b}, ${
            0.5 + hoverProgress * 0.5
          })`;
          ctx.lineWidth = 1.5 + hoverProgress * 1.5;
          drawRoundRect(
            ctx,
            button.x,
            button.y,
            button.width,
            button.height,
            10
          ).stroke();

          ctx.fillStyle = "white";
          ctx.font = `bold ${canvas.width / 28}px 'Segoe UI', sans-serif`;
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.shadowColor = "black";
          ctx.shadowBlur = 4;
          ctx.fillText(
            button.text,
            button.x + button.width / 2,
            button.y + button.height / 2
          );
          ctx.restore();
        });
      }

      function updateInfoPanel() {
        const showInfoStates = [
          "aiming",
          "shooting",
          "waiting",
          "levelTransition",
        ];
        if (!showInfoStates.includes(gameState)) {
          infoDiv.innerHTML = "";
          return;
        }

        const remainingBalls =
          gameState === "aiming"
            ? currentLaunchQueue.length
            : totalBallsLaunchedThisRound - launchIndex;
        const progress =
          levelTargetScore > 0 ? Math.min(score / levelTargetScore, 1) : 0;
        const progressPercent = Math.floor(progress * 100);
        const progressColor = `hsl(${progress * 120}, 100%, 50%)`;

        infoDiv.innerHTML = `Nível: ${
          level + 1
        } | Bolas: ${remainingBalls} | Dano: ${playerDamage}<br>Progresso: <span style="color:${progressColor}">${progressPercent}%</span>`;
      }

      function gameLoop(currentTime) {
        if (!gameLoop.lastTime) {
          gameLoop.lastTime = currentTime;
        }
        const deltaTime = currentTime - gameLoop.lastTime;
        gameLoop.lastTime = currentTime;

        update(deltaTime);
        if (gameState !== "paused") {
          updateBackground();
        }
        draw();
        requestAnimationFrame(gameLoop);
      }

      let perkChoices = [];
      let nextLevelAfterPerk = 0;

      function getPerkOptions() {
        return [
          {
            perk: "addDamage",
            title: "Dano Aumentado",
            description:
              "Aumenta permanentemente o dano de todas as bolas em +1.",
            icon: "damageUp",
            color: "#FF8C00",
            apply: () => {
              basePlayerDamage++;
            },
          },
          {
            perk: "laserChance",
            title: "Precisão Laser",
            description:
              "Chance de disparar um laser ao atingir um bloco.",
            icon: "laser",
            color: "#FF00FF",
            apply: () => {
              playerPerk = "laserChance";
            },
          },
          {
            perk: "addFire",
            title: "Bola de Fogo",
            description: "Adiciona uma Bola de Fogo permanente à sua fila.",
            icon: "fire",
            color: "#FF4500",
            apply: () => {
              permanentPowerUps.push("fire");
            },
          },
          {
            perk: "addGiant",
            title: "Bola Gigante",
            description: "Adiciona uma Bola Gigante permanente à sua fila.",
            icon: "giant",
            color: "#1E90FF",
            apply: () => {
              permanentPowerUps.push("giant");
            },
          },
          {
            perk: "addScatter",
            title: "Chuva de Bolas",
            description:
              "Adiciona uma bola de Chuva de Bolas permanente à sua fila.",
            icon: "scatter",
            color: "#FFFF00",
            apply: () => {
              permanentPowerUps.push("scatter");
            },
          },
        ];
      }

      function setupPerkSelectionScreen(nextLevel) {
        basePlayerDamage++;
        gameState = "perkSelection";
        nextLevelAfterPerk = nextLevel;
        powerUpChoices = [];

        let allPerks = getPerkOptions();
        if (playerPerk) {
          allPerks = allPerks.filter((p) => p.perk !== playerPerk);
        }

        for (let i = allPerks.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [allPerks[i], allPerks[j]] = [allPerks[j], allPerks[i]];
        }
        const selectedPerks = allPerks.slice(0, 3);

        const isPortrait = canvas.height > canvas.width * 1.5;
        const cols = isPortrait ? 1 : 3;
        const rows = isPortrait ? 3 : 1;
        const marginX = canvas.width * 0.05;
        const marginY = canvas.height * 0.03;

        const availableWidth = canvas.width - marginX * (cols + 1);
        const cardWidth = availableWidth / cols;

        const availableHeight = canvas.height * 0.7;
        const cardHeight = isPortrait
          ? availableHeight / rows - marginY
          : cardWidth * 1.7;

        const totalWidth = cardWidth * cols + marginX * (cols - 1);
        const cardsXStart = (canvas.width - totalWidth) / 2;

        const totalHeight = cardHeight * rows + marginY * (rows - 1);
        const cardsYStart =
          canvas.height * 0.5 - totalHeight / 2 + canvas.height * 0.05;

        perkChoices = selectedPerks.map((perk, index) => {
          const col = isPortrait ? 0 : index;
          const row = isPortrait ? index : 0;
          return {
            ...perk,
            x: cardsXStart + col * (cardWidth + marginX),
            width: cardWidth,
            height: cardHeight,
            hoverProgress: 0,
            animProgress: 0,
            targetY: cardsYStart + row * (cardHeight + marginY),
            startY: canvas.height,
          };
        });
        powerUpChoices = perkChoices;
      }

      function drawPerkSelectionScreen() {
        drawStartScreen();
      }

      function handlePerkSelectionClick(event) {
        if (gameState !== "perkSelection") return;
        const rect = canvas.getBoundingClientRect();
        let clickX, clickY;
        if (event.changedTouches) {
          clickX = event.changedTouches[0].clientX - rect.left;
          clickY = event.changedTouches[0].clientY - rect.top;
        } else {
          clickX = event.clientX - rect.left;
          clickY = event.clientY - rect.top;
        }

        for (const choice of perkChoices) {
          if (
            clickX > choice.x &&
            clickX < choice.x + choice.width &&
            clickY > choice.targetY &&
            clickY < choice.targetY + choice.height
          ) {
            choice.apply();
            setupLevel(nextLevelAfterPerk);
            break;
          }
        }
      }

      function setupStartScreen() {
        resizeGame();
        gameState = "startScreen";
        powerUpChoices = [];
        let perks = [
          {
            perk: "laserChance",
            title: "Precisão Laser",
            description:
              "Chance de disparar um laser ao atingir um bloco.",
            icon: "laser",
            color: "#FF00FF",
          },
          {
            perk: "ghost",
            title: "Bola Fantasma",
            description:
              "Comece com uma bola que atravessa os primeiros blocos que toca.",
            icon: "ghost",
            color: "#E6E6FA",
          },
          {
            perk: "multiplier",
            title: "Multiplicador",
            description:
              "Comece com uma bola que se divide em duas ao colidir.",
            icon: "multiplier",
            color: "#800080",
          },
          {
            perk: "fire",
            title: "Bola de Fogo",
            description:
              "Comece com uma bola que explode ao colidir, acertando em área.",
            icon: "fire",
            color: "#FF4500",
          },
          {
            perk: "giant",
            title: "Bola Gigante",
            description: "Comece com uma bola que é maior e causa mais dano.",
            icon: "giant",
            color: "#1E90FF",
          },
          {
            perk: "scatter",
            title: "Chuva de Bolas",
            description: "Comece com uma bola que solta 3 bolinhas ao colidir.",
            icon: "scatter",
            color: "#FFFF00",
          },
        ];

        for (let i = perks.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [perks[i], perks[j]] = [perks[j], perks[i]];
        }
        const selectedPerks = perks.slice(0, 3);

        const isPortrait = canvas.height > canvas.width * 1.5;
        const cols = isPortrait ? 1 : 3;
        const rows = isPortrait ? 3 : 1;
        const marginX = canvas.width * 0.05;
        const marginY = canvas.height * 0.03;

        const availableWidth = canvas.width - marginX * (cols + 1);
        const cardWidth = availableWidth / cols;

        const availableHeight = canvas.height * 0.7;
        const cardHeight = isPortrait
          ? availableHeight / rows - marginY
          : cardWidth * 1.7;

        const totalWidth = cardWidth * cols + marginX * (cols - 1);
        const cardsXStart = (canvas.width - totalWidth) / 2;

        const totalHeight = cardHeight * rows + marginY * (rows - 1);
        const cardsYStart =
          canvas.height * 0.5 - totalHeight / 2 + canvas.height * 0.05;

        powerUpChoices = selectedPerks.map((perk, index) => {
          const col = isPortrait ? 0 : index;
          const row = isPortrait ? index : 0;
          return {
            ...perk,
            x: cardsXStart + col * (cardWidth + marginX),
            width: cardWidth,
            height: cardHeight,
            hoverProgress: 0,
            animProgress: 0,
            targetY: cardsYStart + row * (cardHeight + marginY),
            startY: canvas.height,
          };
        });

        const startScreenClickHandler = (event) => {
          if (gameState === "startScreen") {
            event.preventDefault();
            handleStartScreenClick(event, startScreenClickHandler);
          }
        };
        canvas.addEventListener("click", startScreenClickHandler);
        canvas.addEventListener("touchend", startScreenClickHandler);
      }

      function handleStartScreenClick(event, listener) {
        if (gameState !== "startScreen") return;
        const rect = canvas.getBoundingClientRect();
        let clickX, clickY;
        if (event.changedTouches) {
          clickX = event.changedTouches[0].clientX - rect.left;
          clickY = event.changedTouches[0].clientY - rect.top;
        } else {
          clickX = event.clientX - rect.left;
          clickY = event.clientY - rect.top;
        }

        for (const choice of powerUpChoices) {
          if (
            clickX > choice.x &&
            clickX < choice.x + choice.width &&
            clickY > choice.targetY &&
            clickY < choice.targetY + choice.height
          ) {
            if (choice.perk === "laserChance") {
              playerPerk = "laserChance";
            } else {
              permanentPowerUps.push(choice.perk);
              baseBallsToLaunch = 0;
            }
            canvas.removeEventListener("click", listener);
            canvas.removeEventListener("touchend", listener);
            setupLevel(0);
            break;
          }
        }
      }

      const unpauseGame = () => {
        if (gameState === "paused") {
          gameState = previousGameState;
          uiButtons = [];
        }
      };

      function handleMouseUp(event) {
        event.preventDefault();

        if (gameState === "levelTransition") {
          const elapsedTime = TRANSITION_DURATION - transitionTimer;
          if (elapsedTime > 200) {
            transitionTimer = 0;
          }
          return;
        }

        if (gameState === "perkSelection") {
          handlePerkSelectionClick(event);
          return;
        }

        const rect = canvas.getBoundingClientRect();
        let clickX, clickY;
        if (event.changedTouches) {
          clickX = event.changedTouches[0].clientX - rect.left;
          clickY = event.changedTouches[0].clientY - rect.top;
        } else {
          clickX = event.clientX - rect.left;
          clickY = event.clientY - rect.top;
        }

        const activeStates = ["paused", "gameOver", "levelComplete"];
        if (activeStates.includes(gameState)) {
          for (const button of uiButtons) {
            if (
              clickX > button.x &&
              clickX < button.x + button.width &&
              clickY > button.y &&
              clickY < button.y + button.height
            ) {
              button.onClick();
              return;
            }
          }
        }

        if (isAiming && gameState === "aiming") {
          isAiming = false;
          gameState = "shooting";
          launchBalls();
          playSound("launch");
        }
        isSpeedingUp = false;
      }

      function handleMouseDown(event) {
        event.preventDefault();
        if (gameState === "aiming") {
          isAiming = true;
          const rect = canvas.getBoundingClientRect();
          const touch = event.touches ? event.touches[0] : event;
          mouse.x = touch.clientX - rect.left;
          mouse.y = touch.clientY - rect.top;
          const dx = mouse.x - launchPosition.x;
          const dy = mouse.y - launchPosition.y;
          aimAngle = Math.atan2(dy, dx);
          if (aimAngle > -0.6) aimAngle = -0.6;
          if (aimAngle < -Math.PI + 0.6) aimAngle = -Math.PI + 0.6;
        } else if (gameState === "shooting" || gameState === "round_ending") {
          isSpeedingUp = true;
        }
      }

      function handleMouseMove(event) {
        event.preventDefault();
        const rect = canvas.getBoundingClientRect();
        const touch = event.touches ? event.touches[0] : event;
        mouse.x = touch.clientX - rect.left;
        mouse.y = touch.clientY - rect.top;

        const activeUIStates = [
          "startScreen",
          "perkSelection",
          "gameOver",
          "levelComplete",
          "paused",
        ];
        if (activeUIStates.includes(gameState)) {
          const uiElements = [...(powerUpChoices || []), ...(uiButtons || [])];
          uiElements.forEach((el) => {
            const targetEl = el.targetY ? { ...el, y: el.targetY } : el;
            el.isHovered =
              mouse.x > targetEl.x &&
              mouse.x < targetEl.x + targetEl.width &&
              mouse.y > targetEl.y &&
              mouse.y < targetEl.y + targetEl.height;
          });
        }

        if (isAiming) {
          const dx = mouse.x - launchPosition.x;
          const dy = mouse.y - launchPosition.y;
          aimAngle = Math.atan2(dy, dx);
          if (aimAngle > -0.6) aimAngle = -0.6;
          if (aimAngle < -Math.PI + 0.6) aimAngle = -Math.PI + 0.6;
        }
      }

      canvas.addEventListener("mousedown", handleMouseDown);
      canvas.addEventListener("mousemove", handleMouseMove);
      canvas.addEventListener("mouseup", handleMouseUp);
      canvas.addEventListener("touchstart", handleMouseDown);
      canvas.addEventListener("touchmove", handleMouseMove);
      canvas.addEventListener("touchend", handleMouseUp);

      window.addEventListener("blur", () => {
        if (
          gameState !== "paused" &&
          gameState !== "startScreen" &&
          gameState !== "gameOver" &&
          gameState !== "levelComplete" &&
          gameState !== "perkSelection"
        ) {
          previousGameState = gameState;
          gameState = "paused";
          uiButtons = [];
          isAiming = false;
        }
      });

      window.addEventListener("keydown", (event) => {
        if (event.key === "Escape") {
          if (gameState === "paused") {
            unpauseGame();
          } else if (gameState === "shooting" || gameState === "aiming") {
            previousGameState = gameState;
            gameState = "paused";
            uiButtons = [];
            isAiming = false;
          }
        }

        if (event.key === "1") {
          const activeGameStates = ["aiming", "shooting", "waiting"];
          if (activeGameStates.includes(gameState)) {
            uiButtons = [];
            gameState = "levelComplete";
            playSound("levelUp");
          }
        }
      });

      window.addEventListener("resize", resizeGame);
      setupStartScreen();
      setupBackground();
      gameLoop();
    </script>
  </body>
</html>
